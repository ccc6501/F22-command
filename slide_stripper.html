<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slide Stripper | NGA Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700&family=Rajdhani:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

        :root {
            --bg-void: #050508;
            --bg-deep: #0b0b14;
            --bg-panel: rgba(12, 12, 20, 0.85);
            --glass-border: rgba(255, 215, 0, 0.15);
            --glass-glow: rgba(255, 215, 0, 0.05);
            --neon-gold: #ffd700;
            --neon-cyan: #00e5ff;
            --neon-green: #00ff88;
            --neon-red: #ff3366;
            --neon-orange: #ff9500;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
            --text-dim: #555568;
            --pending-color: #ffd700;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--bg-void);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background:
                radial-gradient(circle at 20% 20%, rgba(255, 215, 0, 0.08), transparent 45%),
                radial-gradient(circle at 80% 10%, rgba(0, 229, 255, 0.06), transparent 50%),
                linear-gradient(90deg, rgba(255, 215, 0, 0.02) 1px, transparent 1px),
                linear-gradient(rgba(255, 215, 0, 0.02) 1px, transparent 1px);
            background-size: auto, auto, 48px 48px, 48px 48px;
            pointer-events: none;
            z-index: 0;
        }

        .header {
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            padding: 0.75rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            z-index: 5;
            position: relative;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            fill: var(--neon-gold);
            filter: drop-shadow(0 0 8px var(--neon-gold));
        }

        .logo-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--neon-gold);
            letter-spacing: 2px;
        }

        .logo-sub {
            font-size: 0.65rem;
            color: var(--text-secondary);
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .nav-tabs {
            display: flex;
            gap: 0.5rem;
        }

        .nav-tab {
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-secondary);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 0.45rem 0.9rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .nav-tab.active {
            color: var(--neon-gold);
            border-color: var(--glass-border);
            background: rgba(255, 215, 0, 0.12);
        }

        .nav-tab:hover {
            color: var(--neon-gold);
            border-color: var(--glass-border);
        }

        .status-bar {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 1.25rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-dot.approved {
            background: var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
        }

        .status-dot.rejected {
            background: var(--neon-red);
            box-shadow: 0 0 10px var(--neon-red);
        }

        .status-dot.pending {
            background: var(--pending-color);
            box-shadow: 0 0 10px var(--pending-color);
        }

        .status-dot.error {
            background: var(--neon-orange);
            box-shadow: 0 0 10px var(--neon-orange);
        }

        .app {
            flex: 1;
            display: flex;
            position: relative;
            z-index: 1;
            min-height: 0;
            min-width: 0;
        }

        .screen {
            display: none;
            width: 100%;
            height: 100%;
            min-height: 0;
            min-width: 0;
        }

        .screen.active {
            display: block;
        }

        .panel {
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
        }

        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            color: var(--neon-gold);
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 0.75rem;
        }

        .btn {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.08));
            border: 1px solid var(--neon-gold);
            color: var(--neon-gold);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 0.6rem 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.15));
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.25);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: transparent;
            border-color: var(--glass-border);
            color: var(--text-secondary);
        }

        .btn-secondary:hover {
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
            box-shadow: 0 0 18px rgba(0, 229, 255, 0.2);
        }

        .btn-danger {
            background: rgba(255, 51, 102, 0.12);
            border-color: rgba(255, 51, 102, 0.7);
            color: var(--neon-red);
        }

        .btn-danger:hover {
            background: rgba(255, 51, 102, 0.2);
            box-shadow: 0 0 18px rgba(255, 51, 102, 0.25);
        }

        .btn-small {
            padding: 0.25rem 0.5rem;
            font-size: 0.65rem;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .input {
            width: 100%;
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            padding: 0.45rem 0.6rem;
            border-radius: 6px;
            transition: border-color 0.2s ease;
        }

        .input:focus {
            outline: none;
            border-color: var(--neon-gold);
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.2rem 0.5rem;
            border-radius: 999px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .badge.pending {
            background: rgba(255, 215, 0, 0.15);
            color: var(--pending-color);
        }

        .badge.approved {
            background: rgba(0, 255, 136, 0.15);
            color: var(--neon-green);
        }

        .badge.rejected {
            background: rgba(255, 51, 102, 0.15);
            color: var(--neon-red);
        }

        .badge.error {
            background: rgba(255, 149, 0, 0.15);
            color: var(--neon-orange);
        }

        .import-layout {
            display: grid;
            grid-template-columns: 1.1fr 0.9fr;
            gap: 1.5rem;
            padding: 1.5rem;
            height: 100%;
        }

        .drop-zone {
            border: 2px dashed rgba(255, 215, 0, 0.35);
            border-radius: 16px;
            padding: 2rem;
            text-align: center;
            color: var(--text-secondary);
            background: rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }

        .drop-zone.dragover {
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
            box-shadow: 0 0 30px rgba(0, 229, 255, 0.15);
        }

        .drop-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .file-list {
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .file-item {
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid var(--glass-border);
            padding: 0.75rem;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }

        .file-meta {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .file-name {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.95rem;
        }

        .file-size {
            font-size: 0.75rem;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
        }

        .mode-toggle {
            display: flex;
            gap: 1rem;
        }

        .mode-option {
            display: flex;
            align-items: center;
            gap: 0.45rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .mode-option input {
            accent-color: var(--neon-gold);
        }

        .review-layout {
            display: grid;
            grid-template-columns: 280px 1fr 340px;
            height: 100%;
            min-height: 0;
            min-width: 0;
        }

        .review-layout>* {
            min-height: 0;
            min-width: 0;
        }

        .slide-list {
            border-right: 1px solid var(--glass-border);
            background: rgba(10, 10, 18, 0.9);
            overflow-y: auto;
            padding: 1rem;
        }

        .slide-list::-webkit-scrollbar,
        .inspect-panel::-webkit-scrollbar,
        .table-preview::-webkit-scrollbar {
            width: 6px;
        }

        .slide-list::-webkit-scrollbar-thumb,
        .inspect-panel::-webkit-scrollbar-thumb,
        .table-preview::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 6px;
        }

        .slide-item {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid transparent;
            border-radius: 10px;
            padding: 0.55rem;
            margin-bottom: 0.6rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slide-item:hover {
            border-color: var(--glass-border);
            background: rgba(255, 215, 0, 0.06);
        }

        .slide-item.active {
            border-color: var(--neon-gold);
            background: rgba(255, 215, 0, 0.12);
            box-shadow: 0 0 18px rgba(255, 215, 0, 0.2);
        }

        .slide-thumb {
            width: 52px;
            height: 40px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }

        .slide-info {
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .slide-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .slide-meta {
            font-size: 0.7rem;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
        }

        .preview-panel {
            position: relative;
            background: var(--bg-deep);
            overflow: hidden;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .zoom-controls label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-family: 'Rajdhani', sans-serif;
        }

        .zoom-controls input[type="range"] {
            width: 120px;
            accent-color: var(--accent);
        }

        .zoom-controls .zoom-value {
            font-size: 0.75rem;
            color: var(--accent);
            font-family: 'JetBrains Mono', monospace;
            min-width: 40px;
        }

        .zoom-controls button {
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
        }

        .preview-viewport {
            flex: 1;
            overflow: auto;
            padding: 1.25rem;
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }

        .preview-viewport.centered {
            align-items: center;
        }

        #preview-canvas {
            max-width: none;
            max-height: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            display: block;
            transform-origin: center center;
            transition: transform 0.1s ease-out;
        }

        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-secondary);
        }

        .empty-title {
            font-family: 'Orbitron', sans-serif;
            margin-top: 0.5rem;
            font-size: 1rem;
        }

        .inspect-panel {
            border-left: 1px solid var(--glass-border);
            padding: 1rem;
            overflow-y: auto;
            background: rgba(10, 10, 18, 0.9);
        }

        .panel-section {
            margin-bottom: 1.5rem;
        }

        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .setting-row input,
        .setting-row select {
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            padding: 0.35rem 0.5rem;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
        }

        .setting-row select {
            font-family: 'Rajdhani', sans-serif;
        }

        .label-list {
            display: flex;
            flex-direction: column;
            gap: 0.45rem;
        }

        .label-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0, 0, 0, 0.25);
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            border: 1px solid var(--glass-border);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .table-preview {
            max-height: 320px;
            overflow-y: auto;
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }

        .table-preview .table-section {
            margin-bottom: 1rem;
        }

        .table-preview .table-section h5 {
            margin: 0;
            padding: 0.5rem 0.75rem;
            background: rgba(0, 240, 255, 0.1);
            border-bottom: 1px solid var(--glass-border);
            color: var(--neon-cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            letter-spacing: 1px;
        }

        .table-preview .empty-tables {
            padding: 1rem;
            text-align: center;
            color: var(--glass-text);
            font-style: italic;
        }

        .table-preview table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.7rem;
        }

        .table-preview th,
        .table-preview td {
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding: 0.35rem 0.5rem;
            text-align: left;
        }

        .table-preview th {
            color: var(--neon-gold);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .actions-row {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .export-layout {
            display: grid;
            grid-template-columns: 0.9fr 1.1fr;
            gap: 1.5rem;
            padding: 1.5rem;
            height: 100%;
        }

        .export-summary {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .summary-card {
            padding: 1rem;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid var(--glass-border);
        }

        .summary-line {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.35rem;
        }

        .export-options {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .export-options label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .export-options input {
            accent-color: var(--neon-gold);
        }

        .shortcut-hint {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-top: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .processing-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .processing-card {
            background: var(--bg-panel);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1.5rem;
            width: 380px;
            text-align: center;
        }

        .progress-bar {
            height: 6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            overflow: hidden;
            margin-top: 0.8rem;
        }

        .progress-fill {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, var(--neon-gold), var(--neon-cyan));
            transition: width 0.2s ease;
        }

        .toast-container {
            position: fixed;
            right: 1.2rem;
            bottom: 1.2rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 30;
        }

        .toast {
            background: var(--bg-panel);
            border: 1px solid var(--glass-border);
            border-left: 3px solid var(--neon-cyan);
            padding: 0.6rem 0.8rem;
            border-radius: 8px;
            font-size: 0.85rem;
            min-width: 220px;
            animation: slideIn 0.25s ease;
        }

        .toast.success {
            border-left-color: var(--neon-green);
        }

        .toast.error {
            border-left-color: var(--neon-red);
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @media (max-width: 1100px) {

            .import-layout,
            .export-layout {
                grid-template-columns: 1fr;
            }

            .review-layout {
                grid-template-columns: 1fr;
                grid-template-rows: 240px 1fr 320px;
            }

            .slide-list {
                border-right: none;
                border-bottom: 1px solid var(--glass-border);
            }

            .inspect-panel {
                border-left: none;
                border-top: 1px solid var(--glass-border);
            }
        }
    </style>
</head>

<body>
    <header class="header">
        <div class="logo">
            <svg class="logo-icon" viewBox="0 0 24 24">
                <path
                    d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z" />
            </svg>
            <div>
                <div class="logo-text">SLIDE STRIPPER</div>
                <div class="logo-sub">NGA Edition</div>
            </div>
        </div>
        <nav class="nav-tabs">
            <button class="nav-tab active" data-screen="import">Import</button>
            <button class="nav-tab" data-screen="review">Review</button>
            <button class="nav-tab" data-screen="export">Export</button>
        </nav>
        <div class="status-bar">
            <div class="status-item"><span class="status-dot pending"></span><span id="count-pending">0</span> Pending
            </div>
            <div class="status-item"><span class="status-dot approved"></span><span id="count-approved">0</span>
                Approved</div>
            <div class="status-item"><span class="status-dot rejected"></span><span id="count-rejected">0</span>
                Rejected</div>
            <div class="status-item"><span class="status-dot error"></span><span id="count-error">0</span> Error</div>
        </div>
    </header>

    <main class="app">
        <section id="screen-import" class="screen active">
            <div class="import-layout">
                <div class="panel" style="padding: 1.5rem;">
                    <div class="section-title">PPTX Intake</div>
                    <div id="drop-zone" class="drop-zone">
                        <div class="drop-title">Drag PPTX decks here</div>
                        <div style="font-size: 0.85rem; margin-bottom: 1.5rem;">or browse to select multiple decks</div>
                        <button class="btn" id="browse-btn">Browse PPTX Files</button>
                        <input id="pptx-input" type="file" accept=".pptx,.pdf" multiple style="display:none;" />
                    </div>
                    <div class="file-list" id="file-list"></div>
                </div>
                <div class="panel" style="padding: 1.5rem; display:flex; flex-direction:column; gap:1.25rem;">
                    <div>
                        <div class="section-title">Session Mode</div>
                        <div class="mode-toggle">
                            <label class="mode-option"><input type="radio" name="mode"
                                    value="overwrite" />Overwrite</label>
                            <label class="mode-option"><input type="radio" name="mode" value="append"
                                    checked />Append</label>
                        </div>
                    </div>
                    <div>
                        <div class="section-title">Processing Snapshot</div>
                        <div style="font-size:0.85rem; color: var(--text-secondary);">Composite render includes main
                            diagram + part labels only.</div>
                        <div class="shortcut-hint">Header/footer, tables, and Kit# are excluded automatically.</div>
                    </div>
                    <div style="margin-top:auto;">
                        <button class="btn" id="start-processing" style="width:100%;">Start Processing</button>
                        <div class="shortcut-hint" style="margin-top:0.5rem;">Tip: You can import additional decks later
                            in append mode.</div>
                    </div>
                </div>
            </div>
        </section>

        <section id="screen-review" class="screen">
            <div class="review-layout">
                <aside class="slide-list" id="slide-list">
                    <div class="section-title">Slides</div>
                </aside>
                <section class="preview-panel">
                    <div class="zoom-controls">
                        <label>Zoom</label>
                        <button class="btn btn-secondary" id="zoom-out">‚àí</button>
                        <input type="range" id="zoom-slider" min="25" max="400" value="100" step="25" />
                        <button class="btn btn-secondary" id="zoom-in">+</button>
                        <span class="zoom-value" id="zoom-value">100%</span>
                        <button class="btn btn-secondary" id="zoom-fit">Fit</button>
                        <button class="btn btn-secondary" id="zoom-reset">1:1</button>
                    </div>
                    <div class="preview-viewport" id="preview-viewport">
                        <canvas id="preview-canvas"></canvas>
                    </div>
                    <div class="empty-state" id="empty-preview">
                        <svg class="logo-icon" viewBox="0 0 24 24" style="width:64px;height:64px;opacity:0.5;">
                            <path
                                d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z" />
                        </svg>
                        <div class="empty-title">NO SLIDE SELECTED</div>
                        <div style="font-size:0.85rem; color: var(--text-dim);">Select a slide to preview composite
                            output</div>
                    </div>
                </section>
                <aside class="inspect-panel">
                    <div class="panel-section">
                        <div class="section-title">Detection Settings</div>
                        <div class="setting-row">
                            <span>Header Zone Ratio</span>
                            <input id="setting-header" type="number" min="0" max="0.5" step="0.01" value="0.35" />
                        </div>
                        <div class="setting-row">
                            <span>Footer Zone Ratio</span>
                            <input id="setting-footer" type="number" min="0" max="0.4" step="0.01" value="0.15" />
                        </div>
                        <div class="setting-row">
                            <span>Min Diagram Area</span>
                            <input id="setting-minarea" type="number" min="0" max="0.5" step="0.01" value="0.15" />
                        </div>
                        <div class="setting-row">
                            <span>Output DPI</span>
                            <input id="setting-dpi" type="number" min="72" max="300" step="1" value="150" />
                        </div>
                        <div class="setting-row">
                            <span>Label Regex Preset</span>
                            <select id="setting-regex-preset">
                                <option value="general">General</option>
                                <option value="strict">Strict 5HY</option>
                                <option value="custom">Custom</option>
                            </select>
                        </div>
                        <div class="setting-row" style="flex-direction:column; align-items:stretch; gap:0.35rem;">
                            <span>Label Regex</span>
                            <input id="setting-regex" type="text" class="input" value="^\d*[A-Z]{1,3}\d+-\d+[A-Z]?$" />
                        </div>
                        <button class="btn btn-secondary" id="apply-settings"
                            style="width:100%; margin-top:0.5rem;">Apply To Next Re-run</button>
                        <button class="btn" id="rescan-all-slides" style="width:100%; margin-top:0.5rem;">üîÑ Rescan All
                            Slides</button>
                    </div>

                    <div class="panel-section">
                        <div class="section-title">Slide Status</div>
                        <div id="slide-status" class="badge pending">Pending</div>
                        <div id="slide-status-reason"
                            style="margin-top:0.5rem; font-size:0.75rem; color: var(--text-dim);"></div>
                    </div>

                    <div class="panel-section">
                        <div class="section-title">Labels</div>
                        <div id="labels-count" class="shortcut-hint">0 labels detected</div>
                        <div class="label-list" id="label-list"></div>
                    </div>

                    <div class="panel-section">
                        <div class="section-title">Tables Preview</div>
                        <div
                            style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                            <div id="tables-count" class="shortcut-hint">0 rows extracted</div>
                            <button class="btn btn-small" id="import-master-json"
                                title="Import master_parts.json from table_extractor">üì• Import JSON</button>
                        </div>
                        <input type="file" id="master-json-input" accept=".json" style="display:none;" />
                        <div class="table-preview" id="table-preview"></div>
                    </div>

                    <div class="panel-section">
                        <div class="section-title">Actions</div>
                        <div class="actions-row">
                            <button class="btn" id="approve-slide">Approve (A)</button>
                            <button class="btn btn-danger" id="reject-slide">Reject (R)</button>
                            <button class="btn btn-secondary" id="rerun-slide">Re-run (Shift+R)</button>
                            <button class="btn btn-secondary" id="open-mapper">Open in Mapper</button>
                        </div>
                    </div>
                </aside>
            </div>
        </section>

        <section id="screen-export" class="screen">
            <div class="export-layout">
                <div class="panel" style="padding: 1.5rem;">
                    <div class="section-title">Export Summary</div>
                    <div class="export-summary" id="export-summary"></div>
                    <div class="shortcut-hint">Exports include stable IDs for mapper linking.</div>
                </div>
                <div class="panel" style="padding: 1.5rem; display:flex; flex-direction:column; gap:1.25rem;">
                    <div>
                        <div class="section-title">Export Options</div>
                        <div class="export-options">
                            <label><input type="checkbox" id="opt-approved-only" checked />Approved slides only</label>
                            <label><input type="checkbox" id="opt-images" checked />Include PNG composites</label>
                            <label><input type="checkbox" id="opt-labels" checked />Include labels.json</label>
                            <label><input type="checkbox" id="opt-tables" checked />Include master_parts
                                JSON/CSV</label>
                            <label><input type="checkbox" id="opt-sqlite" checked />Include SQLite database</label>
                        </div>
                    </div>
                    <div style="margin-top:auto; display:flex; flex-direction:column; gap:0.5rem;">
                        <button class="btn" id="download-zip">Download ZIP Bundle</button>
                        <button class="btn" id="download-images-zip">üì∑ Download Images ZIP</button>
                        <button class="btn" id="save-images-folder">üìÅ Save Images to Folder</button>
                        <button class="btn btn-secondary" id="download-sqlite">Download SQLite Only</button>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <div class="processing-overlay" id="processing-overlay">
        <div class="processing-card">
            <div class="section-title" id="processing-title">Processing Slides</div>
            <div id="processing-sub" style="font-size:0.85rem; color: var(--text-secondary);">Initializing...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="processing-bar"></div>
            </div>
        </div>
    </div>

    <div class="toast-container" id="toast-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/sql-wasm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        'use strict';

        // PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

        const EMU_PER_INCH = 914400;
        const REL_NS = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships';
        const DEFAULT_SLIDE_SIZE = { cx: 9144000, cy: 6858000 };
        const FOOTER_KEYWORDS = ['REFERENCE', 'PROPRIETARY', 'LOCKHEED', 'MARTIN', 'INFORMATION', 'CONFIDENTIAL'];
        const LABEL_PRESETS = {
            general: '^\\d*[A-Z]{1,3}\\d+-\\d+[A-Z]?$',
            strict: '^5HY\\d{5}-\\d{3}[A-Z]?$'
        };

        const state = {
            files: [],
            appendMode: 'append',
            decks: new Map(),
            deckZipCache: new Map(),
            pdfCache: new Map(),  // Cache PDF documents for re-runs
            slides: [],
            slideByUid: new Map(),
            labelsBySlide: new Map(),
            tableRows: [],
            masterPartsData: null,  // Loaded from master_parts.json
            imageCache: new Map(),
            currentSlideIdx: -1,
            zoom: 100,
            settings: {
                headerZoneRatio: 0.35,
                footerZoneRatio: 0.15,
                minDiagramAreaRatio: 0.15,
                cropPadRatio: 0.01,
                dpi: 150,
                labelRegexPreset: 'general',
                labelRegex: LABEL_PRESETS.general
            }
        };

        const ui = {
            screens: {
                import: document.getElementById('screen-import'),
                review: document.getElementById('screen-review'),
                export: document.getElementById('screen-export')
            },
            tabs: Array.from(document.querySelectorAll('.nav-tab')),
            dropZone: document.getElementById('drop-zone'),
            fileList: document.getElementById('file-list'),
            pptxInput: document.getElementById('pptx-input'),
            browseBtn: document.getElementById('browse-btn'),
            startProcessing: document.getElementById('start-processing'),
            slideList: document.getElementById('slide-list'),
            previewCanvas: document.getElementById('preview-canvas'),
            previewViewport: document.getElementById('preview-viewport'),
            emptyPreview: document.getElementById('empty-preview'),
            zoomSlider: document.getElementById('zoom-slider'),
            zoomValue: document.getElementById('zoom-value'),
            zoomIn: document.getElementById('zoom-in'),
            zoomOut: document.getElementById('zoom-out'),
            zoomFit: document.getElementById('zoom-fit'),
            zoomReset: document.getElementById('zoom-reset'),
            labelList: document.getElementById('label-list'),
            labelsCount: document.getElementById('labels-count'),
            tablePreview: document.getElementById('table-preview'),
            tablesCount: document.getElementById('tables-count'),
            importMasterJson: document.getElementById('import-master-json'),
            masterJsonInput: document.getElementById('master-json-input'),
            slideStatus: document.getElementById('slide-status'),
            slideStatusReason: document.getElementById('slide-status-reason'),
            approveBtn: document.getElementById('approve-slide'),
            rejectBtn: document.getElementById('reject-slide'),
            rerunBtn: document.getElementById('rerun-slide'),
            openMapperBtn: document.getElementById('open-mapper'),
            processingOverlay: document.getElementById('processing-overlay'),
            processingTitle: document.getElementById('processing-title'),
            processingSub: document.getElementById('processing-sub'),
            processingBar: document.getElementById('processing-bar'),
            exportSummary: document.getElementById('export-summary'),
            downloadZip: document.getElementById('download-zip'),
            downloadImagesZip: document.getElementById('download-images-zip'),
            saveImagesFolder: document.getElementById('save-images-folder'),
            downloadSqlite: document.getElementById('download-sqlite'),
            rescanAllSlides: document.getElementById('rescan-all-slides'),
            toastContainer: document.getElementById('toast-container'),
            statusCounts: {
                pending: document.getElementById('count-pending'),
                approved: document.getElementById('count-approved'),
                rejected: document.getElementById('count-rejected'),
                error: document.getElementById('count-error')
            },
            settings: {
                header: document.getElementById('setting-header'),
                footer: document.getElementById('setting-footer'),
                minarea: document.getElementById('setting-minarea'),
                dpi: document.getElementById('setting-dpi'),
                regexPreset: document.getElementById('setting-regex-preset'),
                regex: document.getElementById('setting-regex'),
                apply: document.getElementById('apply-settings')
            },
            exportOptions: {
                approvedOnly: document.getElementById('opt-approved-only'),
                images: document.getElementById('opt-images'),
                labels: document.getElementById('opt-labels'),
                tables: document.getElementById('opt-tables'),
                sqlite: document.getElementById('opt-sqlite')
            }
        };

        const DB_NAME = 'slideStripperDB';
        const DB_VERSION = 1;
        let dbPromise = null;
        let sqlInitPromise = null;

        function openDb() {
            if (dbPromise) return dbPromise;
            dbPromise = new Promise((resolve, reject) => {
                const req = indexedDB.open(DB_NAME, DB_VERSION);
                req.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('decks')) {
                        db.createObjectStore('decks', { keyPath: 'deck_id' });
                    }
                    if (!db.objectStoreNames.contains('slides')) {
                        db.createObjectStore('slides', { keyPath: 'slide_uid' });
                    }
                    if (!db.objectStoreNames.contains('images')) {
                        db.createObjectStore('images', { keyPath: 'image_id' });
                    }
                    if (!db.objectStoreNames.contains('labels')) {
                        db.createObjectStore('labels', { keyPath: 'slide_uid' });
                    }
                    if (!db.objectStoreNames.contains('table_rows')) {
                        const store = db.createObjectStore('table_rows', { keyPath: 'table_row_id' });
                        store.createIndex('slide_uid', 'slide_uid', { unique: false });
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
            return dbPromise;
        }

        async function dbPut(storeName, value) {
            const db = await openDb();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readwrite');
                tx.objectStore(storeName).put(value);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function dbGet(storeName, key) {
            const db = await openDb();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readonly');
                const req = tx.objectStore(storeName).get(key);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function dbGetAll(storeName) {
            const db = await openDb();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readonly');
                const req = tx.objectStore(storeName).getAll();
                req.onsuccess = () => resolve(req.result || []);
                req.onerror = () => reject(req.error);
            });
        }

        async function dbDelete(storeName, key) {
            const db = await openDb();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readwrite');
                tx.objectStore(storeName).delete(key);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function dbClearAll() {
            const db = await openDb();
            const stores = ['decks', 'slides', 'images', 'labels', 'table_rows'];
            return new Promise((resolve, reject) => {
                const tx = db.transaction(stores, 'readwrite');
                stores.forEach((store) => tx.objectStore(store).clear());
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function deleteTableRowsForSlide(slideUid) {
            const db = await openDb();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('table_rows', 'readwrite');
                const store = tx.objectStore('table_rows');
                const index = store.index('slide_uid');
                const req = index.openCursor(IDBKeyRange.only(slideUid));
                req.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    }
                };
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        function setActiveScreen(name) {
            Object.values(ui.screens).forEach(screen => screen.classList.remove('active'));
            if (ui.screens[name]) ui.screens[name].classList.add('active');
            ui.tabs.forEach(tab => tab.classList.toggle('active', tab.dataset.screen === name));
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            ui.toastContainer.appendChild(toast);
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        function updateStatusCounts() {
            const counts = { pending: 0, approved: 0, rejected: 0, error: 0 };
            state.slides.forEach(slide => {
                if (counts[slide.status] !== undefined) counts[slide.status]++;
            });
            ui.statusCounts.pending.textContent = counts.pending;
            ui.statusCounts.approved.textContent = counts.approved;
            ui.statusCounts.rejected.textContent = counts.rejected;
            ui.statusCounts.error.textContent = counts.error;
            updateExportSummary();
        }

        function formatBytes(bytes) {
            if (!bytes && bytes !== 0) return '0 B';
            const units = ['B', 'KB', 'MB', 'GB'];
            let idx = 0;
            let val = bytes;
            while (val > 1024 && idx < units.length - 1) {
                val /= 1024;
                idx++;
            }
            return `${val.toFixed(1)} ${units[idx]}`;
        }

        function renderFileList() {
            ui.fileList.innerHTML = '';
            if (!state.files.length) return;

            state.files.forEach((file, idx) => {
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
            <div class="file-meta">
                <div class="file-name">${file.name}</div>
                <div class="file-size">${formatBytes(file.size)}</div>
            </div>
            <button class="btn btn-secondary" data-index="${idx}">Remove</button>
        `;
                item.querySelector('button').addEventListener('click', () => {
                    state.files.splice(idx, 1);
                    renderFileList();
                });
                ui.fileList.appendChild(item);
            });
        }

        function renderSlideList() {
            const activeUid = state.slides[state.currentSlideIdx]?.slide_uid;
            ui.slideList.innerHTML = '<div class="section-title">Slides</div>';

            state.slides.forEach((slide, idx) => {
                const item = document.createElement('div');
                item.className = 'slide-item';
                if (slide.slide_uid === activeUid) item.classList.add('active');

                const thumbUrl = state.imageCache.get(slide.composite?.image_id)?.url || '';
                const statusDot = slide.status === 'approved' ? 'approved' :
                    slide.status === 'rejected' ? 'rejected' :
                        slide.status === 'error' ? 'error' : 'pending';

                item.innerHTML = `
            <div class="slide-thumb" style="background-image: url('${thumbUrl}');"></div>
            <div class="slide-info">
                <div class="slide-title">${slide.title_guess || 'Untitled Slide'}</div>
                <div class="slide-meta">#${String(slide.slide_number).padStart(3, '0')} | ${slide.deck_id.replace('sha1:', '').slice(0, 8)}</div>
            </div>
            <span class="status-dot ${statusDot}"></span>
        `;
                item.addEventListener('click', () => selectSlide(idx));
                ui.slideList.appendChild(item);
            });
        }

        async function selectSlide(index) {
            state.currentSlideIdx = index;
            renderSlideList();

            const slide = state.slides[index];
            if (!slide) return;
            await renderPreview(slide);
            renderSlideStatus(slide);
            renderLabels(slide.slide_uid);
            renderTables(slide.slide_uid);
            // Fit zoom to new slide
            setTimeout(zoomToFit, 50);
        }

        function renderSlideStatus(slide) {
            ui.slideStatus.className = `badge ${slide.status}`;
            ui.slideStatus.textContent = slide.status;
            ui.slideStatusReason.textContent = slide.status_reason || '';
        }

        async function renderPreview(slide) {
            if (!slide?.composite?.image_id) {
                ui.emptyPreview.style.display = 'block';
                return;
            }

            const blob = await getImageBlob(slide.composite.image_id);
            if (!blob) {
                ui.emptyPreview.style.display = 'block';
                return;
            }

            const img = await loadImageFromBlob(blob);
            ui.previewCanvas.width = img.width;
            ui.previewCanvas.height = img.height;
            const ctx = ui.previewCanvas.getContext('2d');
            ctx.clearRect(0, 0, img.width, img.height);
            ctx.drawImage(img, 0, 0);
            ui.emptyPreview.style.display = 'none';
        }

        function renderLabels(slideUid) {
            const payload = state.labelsBySlide.get(slideUid);
            const labels = payload?.labels || [];
            ui.labelList.innerHTML = '';
            ui.labelsCount.textContent = `${labels.length} labels detected`;

            if (!labels.length) return;
            labels.forEach(label => {
                const el = document.createElement('div');
                el.className = 'label-item';
                el.textContent = label.text;
                ui.labelList.appendChild(el);
            });
        }

        function renderTables(slideUid) {
            const slide = state.slideByUid.get(slideUid);
            const slideNumber = slide?.slide_number;
            const labelPayload = state.labelsBySlide.get(slideUid);
            const labels = labelPayload?.labels || [];

            // Get master parts data for this slide number
            let masterRows = [];
            if (state.masterPartsData?.all_rows && slideNumber) {
                masterRows = state.masterPartsData.all_rows.filter(r => r.slide_number === slideNumber);
            }

            // Count
            const masterRowCount = masterRows.length;
            const labelCount = labels.length;

            if (state.masterPartsData) {
                ui.tablesCount.textContent = `${masterRowCount} parts from JSON, ${labelCount} diagram labels`;
            } else {
                ui.tablesCount.textContent = `${labelCount} diagram labels (no JSON loaded)`;
            }

            // Build combined display
            let html = '';

            // Master parts data from JSON
            if (masterRows.length) {
                const columns = ['dash', 'name', 'op_card', 'drawing', 'sheet', 'material'];
                const displayNames = ['Dash', 'Name', 'OP Card', 'Drawing', 'Sheet', 'Material'];

                const header = displayNames.map(c => `<th>${escapeHtml(c)}</th>`).join('');
                const body = masterRows.map(row => {
                    const cells = columns.map(c => `<td>${escapeHtml(String(row[c] || ''))}</td>`).join('');
                    return `<tr>${cells}</tr>`;
                }).join('');
                html += `<div class="table-section"><h5>Parts Data (from JSON)</h5><table><thead><tr>${header}</tr></thead><tbody>${body}</tbody></table></div>`;
            } else if (state.masterPartsData) {
                html += `<div class="table-section"><h5>Parts Data</h5><div class="empty-tables">No parts for slide ${slideNumber}</div></div>`;
            }

            // Labels from diagram (part numbers extracted from the image)
            if (labels.length) {
                const labelSample = labels.slice(0, 20);
                const labelHeader = '<th>Label</th><th>X</th><th>Y</th><th>Source</th>';
                const labelBody = labelSample.map(lbl => {
                    const x = Math.round(lbl.center?.[0] || lbl.bbox?.[0] || 0);
                    const y = Math.round(lbl.center?.[1] || lbl.bbox?.[1] || 0);
                    const src = lbl.source?.pdf ? 'PDF' : 'PPTX';
                    return `<tr><td><strong>${escapeHtml(lbl.text)}</strong></td><td>${x}</td><td>${y}</td><td>${src}</td></tr>`;
                }).join('');
                html += `<div class="table-section"><h5>Diagram Labels (Part Numbers)</h5><table><thead><tr>${labelHeader}</tr></thead><tbody>${labelBody}</tbody></table></div>`;
            }

            if (!html) {
                html = '<div class="empty-tables">No data - import master_parts.json</div>';
            }

            ui.tablePreview.innerHTML = html;
        }

        function updateExportSummary() {
            const totalSlides = state.slides.length;
            const approvedSlides = state.slides.filter(s => s.status === 'approved').length;
            const rejectedSlides = state.slides.filter(s => s.status === 'rejected').length;
            const pendingSlides = state.slides.filter(s => s.status === 'pending').length;
            const errorSlides = state.slides.filter(s => s.status === 'error').length;
            const totalRows = state.tableRows.length;

            ui.exportSummary.innerHTML = `
        <div class="summary-card">
            <div class="summary-line"><span>Total Slides</span><span>${totalSlides}</span></div>
            <div class="summary-line"><span>Approved</span><span>${approvedSlides}</span></div>
            <div class="summary-line"><span>Rejected</span><span>${rejectedSlides}</span></div>
            <div class="summary-line"><span>Pending</span><span>${pendingSlides}</span></div>
            <div class="summary-line"><span>Error</span><span>${errorSlides}</span></div>
        </div>
        <div class="summary-card">
            <div class="summary-line"><span>Table Rows</span><span>${totalRows}</span></div>
            <div class="summary-line"><span>Decks Imported</span><span>${state.decks.size}</span></div>
        </div>
    `;
        }

        function updateSettingsFromUI() {
            state.settings.headerZoneRatio = clampNumber(parseFloat(ui.settings.header.value), 0, 0.4, 0.15);
            state.settings.footerZoneRatio = clampNumber(parseFloat(ui.settings.footer.value), 0, 0.4, 0.15);
            state.settings.minDiagramAreaRatio = clampNumber(parseFloat(ui.settings.minarea.value), 0, 0.5, 0.15);
            state.settings.dpi = clampNumber(parseInt(ui.settings.dpi.value, 10), 72, 300, 150);

            const preset = ui.settings.regexPreset.value;
            if (preset !== 'custom') {
                state.settings.labelRegexPreset = preset;
                state.settings.labelRegex = LABEL_PRESETS[preset];
                ui.settings.regex.value = state.settings.labelRegex;
            } else {
                state.settings.labelRegexPreset = 'custom';
                state.settings.labelRegex = ui.settings.regex.value.trim() || LABEL_PRESETS.general;
            }
        }

        function clampNumber(value, min, max, fallback) {
            if (Number.isNaN(value)) return fallback;
            return Math.max(min, Math.min(max, value));
        }

        function escapeHtml(str) {
            return str.replace(/[&<>\"]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;' }[c]));
        }

        function normalizeText(text) {
            return (text || '').replace(/\s+/g, ' ').trim();
        }

        function emuToPx(emu, dpi) {
            return Math.round((emu * dpi) / EMU_PER_INCH);
        }

        function parseXml(xmlString) {
            const doc = new DOMParser().parseFromString(xmlString, 'application/xml');
            const error = doc.querySelector('parsererror');
            if (error) {
                throw new Error('XML parse error');
            }
            return doc;
        }

        function getNodesByLocalName(doc, name) {
            return Array.from(doc.getElementsByTagNameNS('*', name));
        }

        function extractXfrm(node) {
            const xfrm = node.getElementsByTagNameNS('*', 'xfrm')[0];
            if (!xfrm) return null;
            const off = xfrm.getElementsByTagNameNS('*', 'off')[0];
            const ext = xfrm.getElementsByTagNameNS('*', 'ext')[0];
            if (!off || !ext) return null;
            let x = parseInt(off.getAttribute('x') || '0', 10);
            let y = parseInt(off.getAttribute('y') || '0', 10);
            let cx = parseInt(ext.getAttribute('cx') || '0', 10);
            let cy = parseInt(ext.getAttribute('cy') || '0', 10);
            const rot = parseInt(xfrm.getAttribute('rot') || '0', 10);
            const flipH = xfrm.getAttribute('flipH') === '1';
            const flipV = xfrm.getAttribute('flipV') === '1';
            // Allow zero-dimension shapes (lines)
            if (cx === 0 && cy === 0) return null;

            // Walk up to find any group transforms and apply them
            const groupTransform = getGroupTransform(node);

            // Transform: The shape's local coords are relative to immediate parent group's chOff
            // getGroupTransform returns accumulated offsets and scales, where offsetX/Y already
            // represents the final slide position of the group's origin
            // We need: finalX = groupOffset + (localX - chOff) * scale
            x = groupTransform.offsetX + (x - groupTransform.chOffX) * groupTransform.scaleX;
            y = groupTransform.offsetY + (y - groupTransform.chOffY) * groupTransform.scaleY;
            cx = cx * groupTransform.scaleX;
            cy = cy * groupTransform.scaleY;

            return { x, y, cx, cy, rot, flipH, flipV };
        }

        function getGroupTransform(node) {
            // Collect all parent groups from innermost to outermost
            const groups = [];
            let current = node.parentElement;

            while (current) {
                const localName = current.localName || '';
                if (localName === 'grpSp') {
                    const grpSpPr = current.getElementsByTagNameNS('*', 'grpSpPr')[0];
                    if (grpSpPr) {
                        const groupXfrm = grpSpPr.getElementsByTagNameNS('*', 'xfrm')[0];
                        if (groupXfrm) {
                            const grpOff = groupXfrm.getElementsByTagNameNS('*', 'off')[0];
                            const grpExt = groupXfrm.getElementsByTagNameNS('*', 'ext')[0];
                            const chOff = groupXfrm.getElementsByTagNameNS('*', 'chOff')[0];
                            const chExt = groupXfrm.getElementsByTagNameNS('*', 'chExt')[0];

                            const grpX = grpOff ? parseInt(grpOff.getAttribute('x') || '0', 10) : 0;
                            const grpY = grpOff ? parseInt(grpOff.getAttribute('y') || '0', 10) : 0;
                            const grpCx = grpExt ? parseInt(grpExt.getAttribute('cx') || '0', 10) : 0;
                            const grpCy = grpExt ? parseInt(grpExt.getAttribute('cy') || '0', 10) : 0;
                            const chX = chOff ? parseInt(chOff.getAttribute('x') || '0', 10) : 0;
                            const chY = chOff ? parseInt(chOff.getAttribute('y') || '0', 10) : 0;
                            const chCx = chExt ? parseInt(chExt.getAttribute('cx') || '0', 10) : grpCx;
                            const chCy = chExt ? parseInt(chExt.getAttribute('cy') || '0', 10) : grpCy;

                            groups.push({ grpX, grpY, grpCx, grpCy, chX, chY, chCx, chCy });
                        }
                    }
                }
                current = current.parentElement;
            }

            // No groups - return identity transform
            if (groups.length === 0) {
                return { offsetX: 0, offsetY: 0, chOffX: 0, chOffY: 0, scaleX: 1, scaleY: 1 };
            }

            // The innermost group is first - its chOff is what the shape coords are relative to
            const innermost = groups[0];
            let chOffX = innermost.chX;
            let chOffY = innermost.chY;
            let scaleX = 1;
            let scaleY = 1;

            // Process from innermost to outermost, computing cumulative scale
            // and where the innermost child origin maps to
            // We track where point (chOffX, chOffY) in child space maps to slide space
            let originX = 0;
            let originY = 0;

            for (let i = 0; i < groups.length; i++) {
                const g = groups[i];
                const sX = g.chCx > 0 ? g.grpCx / g.chCx : 1;
                const sY = g.chCy > 0 ? g.grpCy / g.chCy : 1;

                if (i === 0) {
                    // First group: map the child origin (chOff) to parent space
                    // Point at chOff maps to grpX + (chOff - chOff) * scale = grpX + 0 = grpX
                    originX = g.grpX;
                    originY = g.grpY;
                } else {
                    // Subsequent groups: transform the current origin through this group
                    originX = g.grpX + (originX - g.chX) * sX;
                    originY = g.grpY + (originY - g.chY) * sY;
                }
                scaleX *= sX;
                scaleY *= sY;
            }

            // Now in extractXfrm: finalX = originX + (shapeX - chOffX) * scaleX
            return { offsetX: originX, offsetY: originY, chOffX, chOffY, scaleX, scaleY };
        }

        function extractText(node) {
            const tNodes = node.getElementsByTagNameNS('*', 't');
            const parts = Array.from(tNodes).map(t => t.textContent || '');
            return normalizeText(parts.join(' '));
        }

        function getShapeId(node) {
            const cNvPr = node.getElementsByTagNameNS('*', 'cNvPr')[0];
            return cNvPr ? cNvPr.getAttribute('id') || null : null;
        }

        function isTitlePlaceholder(node) {
            const ph = node.getElementsByTagNameNS('*', 'ph')[0];
            if (!ph) return false;
            const type = ph.getAttribute('type');
            return type === 'title' || type === 'ctrTitle';
        }

        function resolveTargetPath(basePath, target) {
            if (!target) return null;
            let path = target.startsWith('/') ? target.slice(1) : target;
            const baseParts = basePath.split('/').slice(0, -1);
            const targetParts = path.split('/');
            for (const part of targetParts) {
                if (part === '..') {
                    baseParts.pop();
                } else if (part !== '.') {
                    baseParts.push(part);
                }
            }
            return baseParts.join('/');
        }

        function getImageTypeFromPath(path) {
            const lower = path.toLowerCase();
            if (lower.endsWith('.png')) return 'image/png';
            if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
            if (lower.endsWith('.gif')) return 'image/gif';
            return '';
        }

        function isUnsupportedImage(path) {
            const lower = path.toLowerCase();
            return lower.endsWith('.emf') || lower.endsWith('.wmf');
        }

        async function loadImageFromBlob(blob) {
            return new Promise((resolve, reject) => {
                const url = URL.createObjectURL(blob);
                const img = new Image();
                img.onload = () => {
                    URL.revokeObjectURL(url);
                    resolve(img);
                };
                img.onerror = () => {
                    URL.revokeObjectURL(url);
                    reject(new Error('Image load failed'));
                };
                img.src = url;
            });
        }

        async function sha1Buffer(buffer) {
            const hash = await crypto.subtle.digest('SHA-1', buffer);
            return 'sha1:' + Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        async function sha1Text(text) {
            const encoder = new TextEncoder();
            return sha1Buffer(encoder.encode(text));
        }

        function updateProgress(current, total, message) {
            const pct = total ? Math.round((current / total) * 100) : 0;
            ui.processingSub.textContent = message;
            ui.processingBar.style.width = `${pct}%`;
        }

        function setProcessing(active, title) {
            ui.processingOverlay.style.display = active ? 'flex' : 'none';
            ui.processingTitle.textContent = title || 'Processing Slides';
            ui.processingBar.style.width = '0%';
        }

        function getLabelRegex() {
            try {
                return new RegExp(state.settings.labelRegex, 'i');
            } catch (err) {
                showToast('Invalid regex, falling back to general preset', 'error');
                state.settings.labelRegex = LABEL_PRESETS.general;
                ui.settings.regex.value = LABEL_PRESETS.general;
                return new RegExp(LABEL_PRESETS.general, 'i');
            }
        }

        function isHeaderShape(shape, slideH) {
            if (!shape?.bbox) return false;
            if (shape.bbox.bottom <= slideH * state.settings.headerZoneRatio) return true;
            const text = (shape.text || '').toUpperCase();
            if (text.includes('KIT #') || text.includes('KIT#')) return true;
            if (shape.isTitle) return true;
            return false;
        }

        function isFooterText(shape, slideH) {
            if (!shape?.bbox || !shape.text) return false;
            if (shape.bbox.top < slideH * (1 - state.settings.footerZoneRatio)) return false;
            const text = shape.text.toUpperCase();
            return FOOTER_KEYWORDS.some(k => text.includes(k));
        }

        function isPartLabel(text, regex) {
            if (!text) return false;
            return regex.test(text.trim());
        }

        function unionBBox(a, b) {
            if (!a) return b;
            return {
                left: Math.min(a.left, b.left),
                top: Math.min(a.top, b.top),
                right: Math.max(a.right, b.right),
                bottom: Math.max(a.bottom, b.bottom)
            };
        }

        function clampBBox(b, maxW, maxH) {
            return {
                left: Math.max(0, Math.min(maxW, b.left)),
                top: Math.max(0, Math.min(maxH, b.top)),
                right: Math.max(0, Math.min(maxW, b.right)),
                bottom: Math.max(0, Math.min(maxH, b.bottom))
            };
        }

        async function getImageBlob(imageId) {
            if (!imageId) return null;
            if (state.imageCache.has(imageId)) {
                return state.imageCache.get(imageId).blob;
            }
            const record = await dbGet('images', imageId);
            if (!record) return null;
            const url = URL.createObjectURL(record.blob);
            state.imageCache.set(imageId, { blob: record.blob, url });
            return record.blob;
        }

        function updateImageCache(imageId, blob) {
            const existing = state.imageCache.get(imageId);
            if (existing?.url) URL.revokeObjectURL(existing.url);
            state.imageCache.set(imageId, { blob, url: URL.createObjectURL(blob) });
        }

        async function loadDeckZip(deckMeta) {
            if (state.deckZipCache.has(deckMeta.deck_id)) return state.deckZipCache.get(deckMeta.deck_id);
            const buffer = deckMeta.pptx_buffer;
            if (!buffer || buffer.byteLength === 0) {
                throw new Error('Deck file data not available');
            }
            const zip = await JSZip.loadAsync(buffer);
            state.deckZipCache.set(deckMeta.deck_id, zip);
            return zip;
        }

        async function loadExistingSession() {
            const [decks, slides, labels, rows] = await Promise.all([
                dbGetAll('decks'),
                dbGetAll('slides'),
                dbGetAll('labels'),
                dbGetAll('table_rows')
            ]);

            state.decks.clear();
            decks.forEach(deck => state.decks.set(deck.deck_id, deck));

            state.slides = slides || [];
            state.slideByUid.clear();
            state.slides.forEach(slide => state.slideByUid.set(slide.slide_uid, slide));

            state.labelsBySlide.clear();
            labels.forEach(label => state.labelsBySlide.set(label.slide_uid, label));

            state.tableRows = rows || [];

            updateStatusCounts();
            renderSlideList();
            if (state.slides.length) {
                setActiveScreen('review');
                selectSlide(0);
            } else {
                setActiveScreen('import');
            }
        }

        function addFiles(files) {
            const incoming = Array.from(files);
            incoming.forEach(file => {
                const name = file.name.toLowerCase();
                if (!name.endsWith('.pptx') && !name.endsWith('.pdf')) return;
                const exists = state.files.some(f => f.name === file.name && f.size === file.size && f.lastModified === file.lastModified);
                if (!exists) state.files.push(file);
            });
            renderFileList();
        }

        async function startProcessing() {
            if (!state.files.length) {
                showToast('Add at least one PPTX or PDF file', 'info');
                return;
            }

            if (state.appendMode === 'overwrite') {
                await dbClearAll();
                state.slides = [];
                state.slideByUid.clear();
                state.labelsBySlide.clear();
                state.tableRows = [];
                state.imageCache.clear();
                state.deckZipCache.clear();
                state.decks.clear();
            }

            setActiveScreen('review');
            setProcessing(true, 'Processing Slides');

            // Separate files by type
            const pptxFiles = state.files.filter(f => f.name.toLowerCase().endsWith('.pptx'));
            const pdfFiles = state.files.filter(f => f.name.toLowerCase().endsWith('.pdf'));

            // Count total slides
            let totalSlides = 0;
            for (const file of pptxFiles) {
                const buffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(buffer);
                const slideFiles = zip.file(/^ppt\/slides\/slide\d+\.xml$/);
                totalSlides += slideFiles.length;
            }
            for (const file of pdfFiles) {
                const buffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: buffer }).promise;
                totalSlides += pdf.numPages;
            }

            let processed = 0;

            // Process PPTX files
            for (const file of pptxFiles) {
                const buffer = await file.arrayBuffer();
                const bufferCopy = buffer.slice(0);  // Clone buffer before it gets detached
                const deckId = await sha1Buffer(buffer);
                if (state.decks.has(deckId)) {
                    showToast(`Deck already loaded: ${file.name}`, 'info');
                    continue;
                }
                const zip = await JSZip.loadAsync(buffer);
                const presentationXml = await zip.file('ppt/presentation.xml')?.async('string');
                const slideSize = presentationXml ? parseSlideSize(presentationXml) : DEFAULT_SLIDE_SIZE;
                const slideFiles = zip.file(/^ppt\/slides\/slide\d+\.xml$/);
                const slidePaths = slideFiles.map(f => f.name).sort((a, b) => extractSlideNumber(a) - extractSlideNumber(b));

                const deckMeta = {
                    deck_id: deckId,
                    file_name: file.name,
                    size: file.size,
                    last_modified: file.lastModified,
                    slide_count: slidePaths.length,
                    pptx_buffer: bufferCopy,  // Store cloned ArrayBuffer for IDB persistence
                    pptx_type: file.type || 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
                };
                state.decks.set(deckId, deckMeta);
                await dbPut('decks', deckMeta);
                state.deckZipCache.set(deckId, zip);

                for (const slidePath of slidePaths) {
                    const slideNumber = extractSlideNumber(slidePath);
                    const message = `${file.name} - Slide ${slideNumber}`;
                    updateProgress(processed, totalSlides, message);
                    const result = await processSlide(zip, deckMeta, slidePath, slideNumber, slideSize, null);
                    processed += 1;
                    if (result) {
                        state.slides.push(result.slide);
                        state.slideByUid.set(result.slide.slide_uid, result.slide);
                        state.labelsBySlide.set(result.slide.slide_uid, result.labels);
                        state.tableRows.push(...result.tableRows);
                        if (result.image?.image_id) {
                            updateImageCache(result.image.image_id, result.image.blob);
                        }
                        await persistSlideResult(result);
                    }
                }
            }

            // Process PDF files
            for (const file of pdfFiles) {
                const buffer = await file.arrayBuffer();
                const bufferCopy = buffer.slice(0);  // Clone buffer before it gets detached
                const deckId = await sha1Buffer(buffer);
                if (state.decks.has(deckId)) {
                    showToast(`Deck already loaded: ${file.name}`, 'info');
                    continue;
                }

                const pdf = await pdfjsLib.getDocument({ data: buffer }).promise;
                const numPages = pdf.numPages;

                const deckMeta = {
                    deck_id: deckId,
                    file_name: file.name,
                    size: file.size,
                    last_modified: file.lastModified,
                    slide_count: numPages,
                    pptx_buffer: bufferCopy,  // Store cloned ArrayBuffer for IDB persistence
                    pptx_type: 'application/pdf',
                    isPdf: true
                };
                state.decks.set(deckId, deckMeta);
                state.pdfCache.set(deckId, pdf);  // Cache PDF for re-runs
                await dbPut('decks', deckMeta);

                for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                    const message = `${file.name} - Page ${pageNum}`;
                    updateProgress(processed, totalSlides, message);
                    const result = await processPdfPage(pdf, deckMeta, pageNum);
                    processed += 1;
                    if (result) {
                        state.slides.push(result.slide);
                        state.slideByUid.set(result.slide.slide_uid, result.slide);
                        state.labelsBySlide.set(result.slide.slide_uid, result.labels);
                        state.tableRows.push(...result.tableRows);
                        if (result.image?.image_id) {
                            updateImageCache(result.image.image_id, result.image.blob);
                        }
                        await persistSlideResult(result);
                    }
                }
            }

            updateProgress(totalSlides, totalSlides, 'Complete');
            setProcessing(false);
            state.files = [];
            renderFileList();
            updateStatusCounts();
            renderSlideList();
            if (state.slides.length && state.currentSlideIdx === -1) {
                selectSlide(0);
            }
        }

        async function processSlide(zip, deckMeta, slidePath, slideNumber, slideSize, existingSlide) {
            try {
                const slideXml = await zip.file(slidePath).async('string');
                const relPath = slidePath.replace('ppt/slides/', 'ppt/slides/_rels/') + '.rels';
                const relXml = await zip.file(relPath)?.async('string');
                const rels = relXml ? parseRelationships(relXml) : {};
                const doc = parseXml(slideXml);
                const titleGuess = extractTitleGuess(doc, slideSize);

                const textShapes = extractTextShapes(doc);
                const pictures = extractPictures(doc, rels, slidePath, slideSize);
                const connectorLines = extractConnectorLines(doc)
                    .concat(extractCalloutLines(doc))
                    .filter(line => !isHeaderShape(line, slideSize.cy));
                const tables = extractTables(doc);
                const tablesSha1 = await sha1Text(JSON.stringify(tables));

                const labelRegex = getLabelRegex();
                const labels = [];

                textShapes.forEach(shape => {
                    if (isHeaderShape(shape, slideSize.cy) || isFooterText(shape, slideSize.cy)) return;
                    if (!isPartLabel(shape.text, labelRegex)) return;
                    const bboxPx = shape.bboxPx;
                    labels.push({
                        text: shape.text,
                        bbox: [bboxPx.left, bboxPx.top, bboxPx.right, bboxPx.bottom],
                        center: [Math.round((bboxPx.left + bboxPx.right) / 2), Math.round((bboxPx.top + bboxPx.bottom) / 2)],
                        confidence: 0.9,
                        source: { shape_id: shape.shapeId, xml_path: slidePath }
                    });
                });

                const mainPic = pickMainDiagram(pictures, slideSize);
                if (!mainPic) {
                    return buildErrorSlide(deckMeta, slideNumber, titleGuess, 'No main diagram detected');
                }
                if (isUnsupportedImage(mainPic.target)) {
                    return buildErrorSlide(deckMeta, slideNumber, titleGuess, 'Unsupported EMF/WMF image');
                }

                const slideUid = `${deckMeta.deck_id}::slide_${slideNumber}`;
                const version = (existingSlide?.composite?.version || 0) + 1;
                const imageId = `${slideUid}::composite_v${version}`;
                const deckHash = deckMeta.deck_id.replace('sha1:', '');
                const slideTag = String(slideNumber).padStart(4, '0');
                const versionSuffix = version > 1 ? `_v${version}` : '';
                const imageFile = `slides/images/${deckHash}_slide_${slideTag}${versionSuffix}.png`;

                const composite = await renderComposite({
                    zip,
                    allPictures: pictures,
                    mainPic,
                    labels,
                    connectors: connectorLines,
                    slideSize,
                    dpi: state.settings.dpi,
                    headerRatio: state.settings.headerZoneRatio,
                    footerRatio: state.settings.footerZoneRatio
                });

                if (!composite) {
                    return buildErrorSlide(deckMeta, slideNumber, titleGuess, 'Composite render failed');
                }

                const tableRows = flattenTables(deckMeta, slideNumber, slideUid, titleGuess, tables, imageFile, tablesSha1, tables.length);

                const slide = {
                    deck_id: deckMeta.deck_id,
                    slide_number: slideNumber,
                    slide_uid: slideUid,
                    title_guess: titleGuess,
                    status: 'pending',
                    status_reason: null,
                    composite: {
                        image_id: imageId,
                        image_file: imageFile,
                        width: composite.width,
                        height: composite.height,
                        dpi: state.settings.dpi,
                        crop_bbox_px: composite.cropBBox,
                        settings_snapshot: {
                            part_label_regex: state.settings.labelRegex,
                            header_zone_ratio: state.settings.headerZoneRatio,
                            footer_zone_ratio: state.settings.footerZoneRatio,
                            min_diagram_area_ratio: state.settings.minDiagramAreaRatio
                        },
                        version
                    },
                    labels: {
                        count: labels.length,
                        labels_file: 'slides/labels.json'
                    },
                    tables: {
                        table_count: tables.length,
                        rows_count: tableRows.length,
                        tables_sha1: tablesSha1
                    }
                };

                const labelsPayload = {
                    slide_uid: slideUid,
                    image_id: imageId,
                    labels
                };

                const imagePayload = {
                    image_id: imageId,
                    slide_uid: slideUid,
                    blob: composite.blob,
                    width: composite.width,
                    height: composite.height
                };

                return { slide, labels: labelsPayload, tableRows, image: imagePayload };
            } catch (err) {
                console.error(err);
                return buildErrorSlide(deckMeta, slideNumber, null, err.message || 'Slide processing failed');
            }
        }

        function buildErrorSlide(deckMeta, slideNumber, titleGuess, reason) {
            const slideUid = `${deckMeta.deck_id}::slide_${slideNumber}`;
            const slide = {
                deck_id: deckMeta.deck_id,
                slide_number: slideNumber,
                slide_uid: slideUid,
                title_guess: titleGuess,
                status: 'error',
                status_reason: reason,
                composite: null,
                labels: { count: 0, labels_file: 'slides/labels.json' },
                tables: { table_count: 0, rows_count: 0, tables_sha1: null }
            };
            return {
                slide,
                labels: { slide_uid: slideUid, image_id: null, labels: [] },
                tableRows: [],
                image: { image_id: null, blob: new Blob(), width: 0, height: 0 }
            };
        }

        async function processPdfPage(pdf, deckMeta, pageNum) {
            try {
                const page = await pdf.getPage(pageNum);
                const scale = state.settings.dpi / 72; // PDF is 72 DPI, scale to target DPI
                const viewport = page.getViewport({ scale });

                // Render page to canvas
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                await page.render({ canvasContext: ctx, viewport }).promise;

                // Apply header/footer cropping
                const headerHeight = Math.round(canvas.height * state.settings.headerZoneRatio);
                const footerTop = Math.round(canvas.height * (1 - state.settings.footerZoneRatio));
                const cropHeight = footerTop - headerHeight;

                // Create cropped canvas
                const croppedCanvas = document.createElement('canvas');
                croppedCanvas.width = canvas.width;
                croppedCanvas.height = cropHeight;
                const croppedCtx = croppedCanvas.getContext('2d');
                croppedCtx.drawImage(canvas, 0, headerHeight, canvas.width, cropHeight, 0, 0, canvas.width, cropHeight);

                // Extract text for labels using PDF.js text content
                const textContent = await page.getTextContent();
                const labelRegex = getLabelRegex();
                const labels = [];
                const allTextItems = []; // Collect all text for table extraction

                textContent.items.forEach(item => {
                    if (!item.str) return;
                    const tx = item.transform;
                    // PDF text transforms: [scaleX, skewX, skewY, scaleY, translateX, translateY]
                    const x = tx[4] * scale;
                    const y = canvas.height - (tx[5] * scale); // PDF Y is from bottom
                    const width = item.width * scale || 50;
                    const height = Math.abs(tx[3]) * scale || 12;

                    allTextItems.push({
                        str: item.str.trim(),
                        x, y, width, height
                    });

                    // Check if it's a part label (only in content zone)
                    if (!isPartLabel(item.str.trim(), labelRegex)) return;
                    if (y < headerHeight || y > footerTop) return;

                    // Adjust coordinates for cropped image
                    const adjY = y - headerHeight;
                    const bbox = [x, adjY, x + width, adjY + height];
                    const center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];

                    labels.push({
                        text: item.str.trim(),
                        bbox,
                        center,
                        confidence: 0.95,
                        source: { page: pageNum, pdf: true }
                    });
                });

                // Extract tables from PDF header zone
                // Tables typically have rows of text at similar Y positions
                const slideUid = `${deckMeta.deck_id}::slide_${pageNum}`;
                const tableRows = extractPdfTables(allTextItems, headerHeight, deckMeta, pageNum, slideUid);

                // Generate IDs and file paths
                const version = 1;
                const imageId = `${slideUid}::composite_v${version}`;
                const deckHash = deckMeta.deck_id.replace('sha1:', '');
                const slideTag = String(pageNum).padStart(4, '0');
                const imageFile = `slides/images/${deckHash}_slide_${slideTag}.png`;

                const blob = await new Promise(resolve => croppedCanvas.toBlob(resolve, 'image/png'));

                const slide = {
                    deck_id: deckMeta.deck_id,
                    slide_number: pageNum,
                    slide_uid: slideUid,
                    title_guess: `Page ${pageNum}`,
                    status: 'pending',
                    status_reason: null,
                    composite: {
                        image_id: imageId,
                        image_file: imageFile,
                        width: croppedCanvas.width,
                        height: croppedCanvas.height,
                        dpi: state.settings.dpi,
                        crop_bbox_px: { left: 0, top: headerHeight, right: canvas.width, bottom: footerTop },
                        settings_snapshot: {
                            part_label_regex: state.settings.labelRegex,
                            header_zone_ratio: state.settings.headerZoneRatio,
                            footer_zone_ratio: state.settings.footerZoneRatio,
                            min_diagram_area_ratio: state.settings.minDiagramAreaRatio
                        },
                        version
                    },
                    labels: {
                        count: labels.length,
                        labels_file: 'slides/labels.json'
                    },
                    tables: {
                        table_count: tableRows.length > 0 ? 1 : 0,
                        rows_count: tableRows.length,
                        tables_sha1: tableRows.length > 0 ? await sha1Text(JSON.stringify(tableRows)) : null
                    }
                };

                const labelsPayload = {
                    slide_uid: slideUid,
                    image_id: imageId,
                    labels
                };

                const imagePayload = {
                    image_id: imageId,
                    slide_uid: slideUid,
                    blob,
                    width: croppedCanvas.width,
                    height: croppedCanvas.height
                };

                return { slide, labels: labelsPayload, tableRows, image: imagePayload };
            } catch (err) {
                console.error('PDF page processing error:', err);
                return buildErrorSlide(deckMeta, pageNum, `Page ${pageNum}`, err.message || 'PDF page processing failed');
            }
        }

        // Extract table data from PDF text items (in header zone)
        function extractPdfTables(textItems, headerHeight, deckMeta, pageNum, slideUid) {
            // Find text in header zone that looks like table data
            const headerItems = textItems.filter(t => t.y < headerHeight && t.str.length > 0);
            if (headerItems.length < 3) return [];

            // Group items by Y position (same row)
            const rowGroups = {};
            const tolerance = 6; // pixels
            headerItems.forEach(item => {
                const roundedY = Math.round(item.y / tolerance) * tolerance;
                if (!rowGroups[roundedY]) rowGroups[roundedY] = [];
                rowGroups[roundedY].push(item);
            });

            // Sort rows by Y (top to bottom)
            const sortedYs = Object.keys(rowGroups).map(Number).sort((a, b) => a - b);
            if (sortedYs.length < 2) return [];

            // Find header row - look for row containing "Dash" or similar column headers
            let headerRow = null;
            let headerY = null;
            for (const y of sortedYs) {
                const row = rowGroups[y].sort((a, b) => a.x - b.x);
                const rowText = row.map(r => r.str.toLowerCase()).join(' ');
                if (rowText.includes('dash') || rowText.includes('material') ||
                    (row.length >= 4 && rowText.includes('name'))) {
                    headerRow = row;
                    headerY = y;
                    break;
                }
            }

            if (!headerRow) {
                // Fallback: first row with 4+ items
                for (const y of sortedYs) {
                    const row = rowGroups[y].sort((a, b) => a.x - b.x);
                    if (row.length >= 4) {
                        headerRow = row;
                        headerY = y;
                        break;
                    }
                }
            }
            if (!headerRow) return [];

            // Define column positions from header with better boundaries
            const columns = headerRow.map((item, idx) => ({
                name: item.str.trim(),
                x: item.x - 10,
                xEnd: idx < headerRow.length - 1 ? headerRow[idx + 1].x - 10 : item.x + item.width + 200
            }));

            // Get all data items (below header)
            const dataItems = headerItems.filter(t => t.y > headerY);
            if (dataItems.length === 0) return [];

            // Find the Dash column - this determines row boundaries
            const dashColIdx = columns.findIndex(c =>
                c.name.toLowerCase().includes('dash') || c.name.toLowerCase().includes('part')
            );
            const dashCol = dashColIdx >= 0 ? columns[dashColIdx] : columns[0];

            // Find dash values (these define row boundaries)
            const dashPattern = /^\d*[A-Z]{2,3}\d{4,5}-\d+[A-Z]?$/i;
            const dashItems = dataItems.filter(item =>
                item.x >= dashCol.x && item.x < dashCol.xEnd &&
                dashPattern.test(item.str.trim())
            ).sort((a, b) => a.y - b.y);

            // If no dash items found, try simpler row grouping
            if (dashItems.length === 0) {
                // Fall back to original row-based grouping
                const tableRows = [];
                const dataYs = sortedYs.filter(y => y > headerY);

                dataYs.forEach((y, rowIdx) => {
                    const items = rowGroups[y].sort((a, b) => a.x - b.x);
                    const rowData = {};
                    columns.forEach(col => {
                        const matchingItems = items.filter(item =>
                            item.x >= col.x && item.x < col.xEnd
                        );
                        rowData[col.name] = matchingItems.map(i => i.str).join(' ');
                    });

                    const hasData = Object.values(rowData).some(v => v && v.trim().length > 0);
                    if (hasData) {
                        tableRows.push(buildTableRow(rowData, columns, slideUid, deckMeta, pageNum, rowIdx));
                    }
                });
                return tableRows;
            }

            // Build rows based on dash items (each dash = new row)
            const tableRows = [];
            dashItems.forEach((dashItem, rowIdx) => {
                const nextDash = dashItems[rowIdx + 1];
                const rowYStart = dashItem.y - 5;
                const rowYEnd = nextDash ? nextDash.y - 5 : headerHeight;

                // Get all items in this row's Y range
                const rowItems = dataItems.filter(item =>
                    item.y >= rowYStart && item.y < rowYEnd
                );

                // Assign items to columns
                const rowData = {};
                columns.forEach(col => {
                    const colItems = rowItems.filter(item =>
                        item.x >= col.x && item.x < col.xEnd
                    ).sort((a, b) => a.y - b.y);
                    rowData[col.name] = colItems.map(i => i.str.trim()).join(' ');
                });

                tableRows.push(buildTableRow(rowData, columns, slideUid, deckMeta, pageNum, rowIdx));
            });

            return tableRows;
        }

        function buildTableRow(rowData, columns, slideUid, deckMeta, pageNum, rowIdx) {
            const dashCol = Object.keys(rowData).find(k => k.toLowerCase().includes('dash') || k.toLowerCase().includes('part'));
            const zoneCol = Object.keys(rowData).find(k => k.toLowerCase().includes('zone'));
            const seqCol = Object.keys(rowData).find(k => k.toLowerCase().includes('seq'));
            const nameCol = Object.keys(rowData).find(k => k.toLowerCase().includes('name') || k.toLowerCase().includes('desc'));
            const materialCol = Object.keys(rowData).find(k => k.toLowerCase().includes('material') || k.toLowerCase().includes('mat'));
            const opCardCol = Object.keys(rowData).find(k => k.toLowerCase().includes('op') || k.toLowerCase().includes('card'));
            const drawingCol = Object.keys(rowData).find(k => k.toLowerCase().includes('drawing') || k.toLowerCase().includes('dwg'));
            const sheetCol = Object.keys(rowData).find(k => k.toLowerCase().includes('sheet'));

            return {
                table_row_id: `${slideUid}::table_0::row_${rowIdx}`,
                deck_id: deckMeta.deck_id,
                slide_number: pageNum,
                slide_uid: slideUid,
                table_index: 0,
                row_index: rowIdx,
                row_type: 'data',
                dash: dashCol ? rowData[dashCol] : '',
                zone: zoneCol ? rowData[zoneCol] : '',
                sequence: seqCol ? rowData[seqCol] : '',
                name: nameCol ? rowData[nameCol] : '',
                material: materialCol ? rowData[materialCol] : '',
                op_card: opCardCol ? rowData[opCardCol] : '',
                drawing: drawingCol ? rowData[drawingCol] : '',
                sheet: sheetCol ? rowData[sheetCol] : '',
                raw_cells: rowData
            };
        }

        function parseSlideSize(xml) {
            const doc = parseXml(xml);
            const sldSz = doc.getElementsByTagNameNS('*', 'sldSz')[0];
            if (!sldSz) return DEFAULT_SLIDE_SIZE;
            const cx = parseInt(sldSz.getAttribute('cx') || DEFAULT_SLIDE_SIZE.cx, 10);
            const cy = parseInt(sldSz.getAttribute('cy') || DEFAULT_SLIDE_SIZE.cy, 10);
            return { cx, cy };
        }

        function extractSlideNumber(path) {
            const match = path.match(/slide(\d+)\.xml$/i);
            return match ? parseInt(match[1], 10) : 0;
        }

        function parseRelationships(xml) {
            const doc = parseXml(xml);
            const rels = {};
            const nodes = getNodesByLocalName(doc, 'Relationship');
            nodes.forEach(node => {
                const id = node.getAttribute('Id');
                const target = node.getAttribute('Target');
                if (id && target) rels[id] = target;
            });
            return rels;
        }

        function extractTitleGuess(doc, slideSize) {
            const shapes = getNodesByLocalName(doc, 'sp');
            let fallback = null;
            for (const shape of shapes) {
                const text = extractText(shape);
                if (!text) continue;
                if (isTitlePlaceholder(shape)) return text;
                if (!fallback) fallback = text;
            }
            return fallback;
        }

        function extractTextShapes(doc) {
            const shapes = getNodesByLocalName(doc, 'sp');
            const result = [];
            shapes.forEach(shape => {
                const text = extractText(shape);
                if (!text) return;
                const xfrm = extractXfrm(shape);
                if (!xfrm) return;
                const bbox = {
                    left: xfrm.x,
                    top: xfrm.y,
                    right: xfrm.x + xfrm.cx,
                    bottom: xfrm.y + xfrm.cy
                };
                const bboxPx = {
                    left: emuToPx(bbox.left, state.settings.dpi),
                    top: emuToPx(bbox.top, state.settings.dpi),
                    right: emuToPx(bbox.right, state.settings.dpi),
                    bottom: emuToPx(bbox.bottom, state.settings.dpi)
                };
                result.push({
                    text,
                    bbox,
                    bboxPx,
                    isTitle: isTitlePlaceholder(shape),
                    shapeId: getShapeId(shape)
                });
            });
            return result;
        }

        function extractPictures(doc, rels, slidePath, slideSize) {
            const pics = getNodesByLocalName(doc, 'pic');
            return pics.map(pic => {
                const blip = pic.getElementsByTagNameNS('*', 'blip')[0];
                const rId = blip ? blip.getAttributeNS(REL_NS, 'embed') || blip.getAttribute('r:embed') : null;
                const target = rId ? resolveTargetPath(slidePath, rels[rId]) : null;
                const xfrm = extractXfrm(pic);
                if (!xfrm) return null;
                const bbox = {
                    left: xfrm.x,
                    top: xfrm.y,
                    right: xfrm.x + xfrm.cx,
                    bottom: xfrm.y + xfrm.cy
                };
                const bboxPx = {
                    left: emuToPx(bbox.left, state.settings.dpi),
                    top: emuToPx(bbox.top, state.settings.dpi),
                    right: emuToPx(bbox.right, state.settings.dpi),
                    bottom: emuToPx(bbox.bottom, state.settings.dpi)
                };
                const area = (bbox.right - bbox.left) * (bbox.bottom - bbox.top);
                const slideArea = slideSize.cx * slideSize.cy;
                return {
                    target,
                    rId,
                    bbox,
                    bboxPx,
                    areaRatio: slideArea ? area / slideArea : 0
                };
            }).filter(Boolean);
        }

        function extractConnectorLines(doc) {
            const connectors = getNodesByLocalName(doc, 'cxnSp');
            const shapeLines = getNodesByLocalName(doc, 'sp').filter(node => {
                const prst = node.getElementsByTagNameNS('*', 'prstGeom')[0];
                const geom = (prst?.getAttribute('prst') || prst?.getAttribute('val') || '').toLowerCase();
                return geom.includes('line') || geom.includes('connector');
            });

            const nodes = connectors.concat(shapeLines);
            const lines = [];

            nodes.forEach((node, idx) => {
                const xfrm = extractXfrm(node);
                if (!xfrm) return;

                // Get connector preset type
                const prst = node.getElementsByTagNameNS('*', 'prstGeom')[0];
                const connectorType = (prst?.getAttribute('prst') || '').toLowerCase();

                const style = parseLineStyle(node);

                // Get adjustment values for elbow connectors
                const avLst = prst?.getElementsByTagNameNS('*', 'avLst')[0];
                const adjValues = {};
                if (avLst) {
                    const gds = avLst.getElementsByTagNameNS('*', 'gd');
                    Array.from(gds).forEach(gd => {
                        const name = gd.getAttribute('name');
                        const fmla = gd.getAttribute('fmla') || '';
                        const match = fmla.match(/val\s+(-?\d+)/);
                        if (name && match) {
                            adjValues[name] = parseInt(match[1], 10);
                        }
                    });
                }

                const bbox = {
                    left: xfrm.x,
                    top: xfrm.y,
                    right: xfrm.x + xfrm.cx,
                    bottom: xfrm.y + xfrm.cy
                };
                const bboxPx = {
                    left: emuToPx(bbox.left, state.settings.dpi),
                    top: emuToPx(bbox.top, state.settings.dpi),
                    right: emuToPx(bbox.right, state.settings.dpi),
                    bottom: emuToPx(bbox.bottom, state.settings.dpi)
                };

                // Generate line segments based on connector type
                const segments = computeConnectorSegments(bboxPx, xfrm.flipH, xfrm.flipV, connectorType, adjValues);

                segments.forEach(seg => {
                    lines.push({
                        bbox,
                        bboxPx,
                        x1: seg.x1,
                        y1: seg.y1,
                        x2: seg.x2,
                        y2: seg.y2,
                        color: style.color,
                        widthPx: style.widthPx,
                        headArrow: seg.isFirst ? style.headArrow : false,
                        tailArrow: seg.isLast ? style.tailArrow : false
                    });
                });
            });

            return lines;
        }

        function computeConnectorSegments(bboxPx, flipH, flipV, connectorType, adjValues) {
            const left = bboxPx.left;
            const top = bboxPx.top;
            const right = bboxPx.right;
            const bottom = bboxPx.bottom;
            const width = right - left;
            const height = bottom - top;

            // Determine start and end points based on flip
            let startX, startY, endX, endY;

            if (!flipH && !flipV) {
                startX = left; startY = top; endX = right; endY = bottom;
            } else if (flipH && !flipV) {
                startX = right; startY = top; endX = left; endY = bottom;
            } else if (!flipH && flipV) {
                startX = left; startY = bottom; endX = right; endY = top;
            } else {
                startX = right; startY = bottom; endX = left; endY = top;
            }

            // Check if this is an elbow/bent connector
            const isBent = connectorType.includes('bent') || connectorType.includes('elbow');
            const isCurved = connectorType.includes('curved');

            if (isBent && width > 5 && height > 5) {
                // Elbow connector - calculate the bend point
                // Default adj1 is 50000 (50% along the path)
                const adj1 = adjValues.adj1 !== undefined ? adjValues.adj1 : 50000;
                const ratio = adj1 / 100000;

                // Determine bend direction based on which axis is longer
                // and the flip values
                let midX, midY;

                if (Math.abs(endX - startX) >= Math.abs(endY - startY)) {
                    // Horizontal first, then vertical
                    midX = startX + (endX - startX) * ratio;
                    midY = startY;
                    return [
                        { x1: startX, y1: startY, x2: midX, y2: midY, isFirst: true, isLast: false },
                        { x1: midX, y1: midY, x2: midX, y2: endY, isFirst: false, isLast: false },
                        { x1: midX, y1: endY, x2: endX, y2: endY, isFirst: false, isLast: true }
                    ].filter(seg => Math.hypot(seg.x2 - seg.x1, seg.y2 - seg.y1) > 2);
                } else {
                    // Vertical first, then horizontal
                    midX = startX;
                    midY = startY + (endY - startY) * ratio;
                    return [
                        { x1: startX, y1: startY, x2: midX, y2: midY, isFirst: true, isLast: false },
                        { x1: midX, y1: midY, x2: endX, y2: midY, isFirst: false, isLast: false },
                        { x1: endX, y1: midY, x2: endX, y2: endY, isFirst: false, isLast: true }
                    ].filter(seg => Math.hypot(seg.x2 - seg.x1, seg.y2 - seg.y1) > 2);
                }
            }

            // Straight line (or fallback for other types)
            // Handle near-vertical and near-horizontal lines
            if (width < 3 && height >= 3) {
                const cx = (left + right) / 2;
                return [{ x1: cx, y1: startY, x2: cx, y2: endY, isFirst: true, isLast: true }];
            } else if (height < 3 && width >= 3) {
                const cy = (top + bottom) / 2;
                return [{ x1: startX, y1: cy, x2: endX, y2: cy, isFirst: true, isLast: true }];
            }

            return [{ x1: startX, y1: startY, x2: endX, y2: endY, isFirst: true, isLast: true }];
        }

        function resolveAdjValue(value, span) {
            if (value === null || value === undefined) return null;
            if (Math.abs(value) <= 50000 && span > 200000) {
                return (value / 21600) * span;
            }
            return value;
        }

        function intersectRectEdge(cx, cy, tx, ty, bbox) {
            const dx = tx - cx;
            const dy = ty - cy;
            const candidates = [];

            if (dx !== 0) {
                const tLeft = (bbox.left - cx) / dx;
                const yLeft = cy + tLeft * dy;
                if (tLeft > 0 && yLeft >= bbox.top && yLeft <= bbox.bottom) {
                    candidates.push({ t: tLeft, x: bbox.left, y: yLeft });
                }
                const tRight = (bbox.right - cx) / dx;
                const yRight = cy + tRight * dy;
                if (tRight > 0 && yRight >= bbox.top && yRight <= bbox.bottom) {
                    candidates.push({ t: tRight, x: bbox.right, y: yRight });
                }
            }

            if (dy !== 0) {
                const tTop = (bbox.top - cy) / dy;
                const xTop = cx + tTop * dx;
                if (tTop > 0 && xTop >= bbox.left && xTop <= bbox.right) {
                    candidates.push({ t: tTop, x: xTop, y: bbox.top });
                }
                const tBottom = (bbox.bottom - cy) / dy;
                const xBottom = cx + tBottom * dx;
                if (tBottom > 0 && xBottom >= bbox.left && xBottom <= bbox.right) {
                    candidates.push({ t: tBottom, x: xBottom, y: bbox.bottom });
                }
            }

            if (!candidates.length) {
                return {
                    x: Math.min(Math.max(tx, bbox.left), bbox.right),
                    y: Math.min(Math.max(ty, bbox.top), bbox.bottom)
                };
            }

            candidates.sort((a, b) => a.t - b.t);
            return { x: candidates[0].x, y: candidates[0].y };
        }

        function extractCalloutLines(doc) {
            const shapes = getNodesByLocalName(doc, 'sp');
            return shapes.map(node => {
                const prst = node.getElementsByTagNameNS('*', 'prstGeom')[0];
                const geom = (prst?.getAttribute('prst') || '').toLowerCase();
                if (!geom.includes('callout')) return null;

                const xfrm = extractXfrm(node);
                if (!xfrm) return null;

                const adjNodes = Array.from(node.getElementsByTagNameNS('*', 'gd'));
                const adjMap = {};
                adjNodes.forEach(gd => {
                    const name = gd.getAttribute('name');
                    const fmla = gd.getAttribute('fmla') || '';
                    const match = fmla.match(/val\s+(-?\d+)/);
                    if (name && match) {
                        adjMap[name] = parseInt(match[1], 10);
                    }
                });

                const adj3 = resolveAdjValue(adjMap.adj3 ?? null, xfrm.cx);
                const adj4 = resolveAdjValue(adjMap.adj4 ?? null, xfrm.cy);
                if (adj3 === null || adj4 === null) return null;

                const tipX = xfrm.x + adj3;
                const tipY = xfrm.y + adj4;
                const centerX = xfrm.x + xfrm.cx / 2;
                const centerY = xfrm.y + xfrm.cy / 2;

                const bbox = {
                    left: xfrm.x,
                    top: xfrm.y,
                    right: xfrm.x + xfrm.cx,
                    bottom: xfrm.y + xfrm.cy
                };
                const start = intersectRectEdge(centerX, centerY, tipX, tipY, bbox);

                const bboxPx = {
                    left: emuToPx(bbox.left, state.settings.dpi),
                    top: emuToPx(bbox.top, state.settings.dpi),
                    right: emuToPx(bbox.right, state.settings.dpi),
                    bottom: emuToPx(bbox.bottom, state.settings.dpi)
                };
                const style = parseLineStyle(node);
                return {
                    bbox,
                    bboxPx,
                    x1: emuToPx(start.x, state.settings.dpi),
                    y1: emuToPx(start.y, state.settings.dpi),
                    x2: emuToPx(tipX, state.settings.dpi),
                    y2: emuToPx(tipY, state.settings.dpi),
                    color: style.color,
                    widthPx: style.widthPx
                };
            }).filter(Boolean);
        }

        function parseLineStyle(node) {
            const ln = node.getElementsByTagNameNS('*', 'ln')[0];
            const widthEmu = ln ? parseInt(ln.getAttribute('w') || '0', 10) : 0;
            const widthPx = widthEmu ? Math.max(1, Math.round(emuToPx(widthEmu, state.settings.dpi))) : 2;
            let color = '#222222';
            const solid = ln ? ln.getElementsByTagNameNS('*', 'solidFill')[0] : null;
            const srgb = solid ? solid.getElementsByTagNameNS('*', 'srgbClr')[0] : null;
            const val = srgb ? srgb.getAttribute('val') : null;
            if (val && val.length === 6) {
                color = `#${val}`;
            }

            // Extract arrow markers - headEnd is at start (x1,y1), tailEnd is at end (x2,y2)
            let headArrow = false;
            let tailArrow = false;
            if (ln) {
                const headEnd = ln.getElementsByTagNameNS('*', 'headEnd')[0];
                const tailEnd = ln.getElementsByTagNameNS('*', 'tailEnd')[0];
                // Arrow types: none, triangle, stealth, diamond, oval, arrow
                const headType = headEnd?.getAttribute('type') || 'none';
                const tailType = tailEnd?.getAttribute('type') || 'none';
                headArrow = headType !== 'none' && headType !== '';
                tailArrow = tailType !== 'none' && tailType !== '';
            }

            return { color, widthPx, headArrow, tailArrow };
        }

        function estimateLineEndpoints(bboxPx) {
            const width = bboxPx.right - bboxPx.left;
            const height = bboxPx.bottom - bboxPx.top;
            const centerX = (bboxPx.left + bboxPx.right) / 2;
            const centerY = (bboxPx.top + bboxPx.bottom) / 2;

            if (width >= height * 1.5) {
                return { x1: bboxPx.left, y1: centerY, x2: bboxPx.right, y2: centerY };
            }
            if (height >= width * 1.5) {
                return { x1: centerX, y1: bboxPx.top, x2: centerX, y2: bboxPx.bottom };
            }
            return { x1: bboxPx.left, y1: bboxPx.top, x2: bboxPx.right, y2: bboxPx.bottom };
        }

        function extractTables(doc) {
            const frames = getNodesByLocalName(doc, 'graphicFrame');
            const tables = [];
            frames.forEach(frame => {
                const tbl = frame.getElementsByTagNameNS('*', 'tbl')[0];
                if (!tbl) return;
                const rows = [];
                const trNodes = getNodesByLocalName(tbl, 'tr');
                trNodes.forEach(tr => {
                    const cells = [];
                    const tcNodes = getNodesByLocalName(tr, 'tc');
                    tcNodes.forEach(tc => {
                        const text = extractText(tc);
                        cells.push(text);
                    });
                    rows.push(cells);
                });
                if (rows.length) tables.push(rows);
            });
            return tables;
        }

        function pickMainDiagram(pictures, slideSize) {
            let best = null;
            let bestArea = 0;
            for (const pic of pictures) {
                if (!pic.target) continue;
                const bbox = pic.bbox;
                const centerY = (bbox.top + bbox.bottom) / 2;
                if (centerY <= slideSize.cy * state.settings.headerZoneRatio) continue;
                if (pic.areaRatio < state.settings.minDiagramAreaRatio) continue;
                if (pic.areaRatio > bestArea) {
                    bestArea = pic.areaRatio;
                    best = pic;
                }
            }
            return best;
        }

        function drawArrowHead(ctx, x, y, angle, size, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - size * Math.cos(angle - Math.PI / 6), y - size * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x - size * Math.cos(angle + Math.PI / 6), y - size * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function pickArrowMode(line, labelCenters) {
            if (!labelCenters.length) return 'end';
            const dist = (x, y) => Math.min(...labelCenters.map(c => Math.hypot(c.x - x, c.y - y)));
            const dStart = dist(line.x1, line.y1);
            const dEnd = dist(line.x2, line.y2);
            const ratio = Math.min(dStart, dEnd) / Math.max(dStart, dEnd);
            if (ratio < 0.65) {
                return dStart < dEnd ? 'end' : 'start';
            }
            return 'both';
        }

        function drawConnectorLines(ctx, lines, labels) {
            const labelCenters = labels.map(label => ({ x: label.center[0], y: label.center[1] }));
            lines.forEach(line => {
                const width = Math.max(1, line.widthPx || 2);
                const color = line.color || '#222222';
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(line.x1, line.y1);
                ctx.lineTo(line.x2, line.y2);
                ctx.stroke();

                const angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
                const headLen = Math.max(8, width * 3);

                // Use explicit arrow info from PPTX if available
                const hasExplicitArrows = line.headArrow || line.tailArrow;

                if (hasExplicitArrows) {
                    // headEnd in PPTX is at start point (x1, y1)
                    if (line.headArrow) {
                        drawArrowHead(ctx, line.x1, line.y1, angle + Math.PI, headLen, color);
                    }
                    // tailEnd in PPTX is at end point (x2, y2)
                    if (line.tailArrow) {
                        drawArrowHead(ctx, line.x2, line.y2, angle, headLen, color);
                    }
                } else {
                    // Fallback to heuristic based on label proximity
                    const mode = pickArrowMode(line, labelCenters);
                    if (mode === 'end' || mode === 'both') {
                        drawArrowHead(ctx, line.x2, line.y2, angle, headLen, color);
                    }
                    if (mode === 'start' || mode === 'both') {
                        drawArrowHead(ctx, line.x1, line.y1, angle + Math.PI, headLen, color);
                    }
                }
            });
        }

        async function renderComposite({ zip, allPictures, mainPic, labels, connectors, slideSize, dpi, headerRatio, footerRatio }) {
            const slideWidth = emuToPx(slideSize.cx, dpi);
            const slideHeight = emuToPx(slideSize.cy, dpi);
            const headerHeight = Math.round(slideHeight * headerRatio);
            const footerTop = Math.round(slideHeight * (1 - footerRatio));

            const canvas = document.createElement('canvas');
            canvas.width = slideWidth;
            canvas.height = slideHeight;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, slideWidth, slideHeight);

            // Render ALL images from the slide (sorted by z-order if available, otherwise by position)
            // This includes the main diagram and any embedded connector/arrow images
            const sortedPictures = [...allPictures].sort((a, b) => {
                // Images higher on the slide (lower y) are typically background
                return (a.bbox?.top || 0) - (b.bbox?.top || 0);
            });

            for (const pic of sortedPictures) {
                if (!pic.target) continue;
                if (isUnsupportedImage(pic.target)) continue;

                // Skip images entirely in header or footer zones
                const picCenterY = (pic.bboxPx.top + pic.bboxPx.bottom) / 2;
                if (picCenterY < headerHeight || picCenterY > footerTop) continue;

                try {
                    const imgBuffer = await zip.file(pic.target)?.async('arraybuffer');
                    if (!imgBuffer) continue;

                    const contentType = getImageTypeFromPath(pic.target) || 'image/png';
                    const blob = new Blob([imgBuffer], { type: contentType });
                    const img = await loadImageFromBlob(blob);

                    const bbox = pic.bboxPx;
                    const width = bbox.right - bbox.left;
                    const height = bbox.bottom - bbox.top;
                    ctx.drawImage(img, bbox.left, bbox.top, width, height);
                } catch (e) {
                    console.warn('Failed to render image:', pic.target, e);
                }
            }

            // Calculate content bounds (excluding header/footer)
            let union = mainPic ? {
                left: mainPic.bboxPx.left,
                top: mainPic.bboxPx.top,
                right: mainPic.bboxPx.right,
                bottom: mainPic.bboxPx.bottom
            } : { left: slideWidth, top: slideHeight, right: 0, bottom: 0 };

            // Expand bounds for all rendered pictures
            for (const pic of sortedPictures) {
                if (!pic.target || isUnsupportedImage(pic.target)) continue;
                const picCenterY = (pic.bboxPx.top + pic.bboxPx.bottom) / 2;
                if (picCenterY < headerHeight || picCenterY > footerTop) continue;
                union = unionBBox(union, pic.bboxPx);
            }

            // Draw extracted connector lines from PPTX
            if (connectors && connectors.length) {
                connectors.forEach(line => {
                    // Skip connectors in header/footer
                    const lineCenterY = (line.y1 + line.y2) / 2;
                    if (lineCenterY < headerHeight || lineCenterY > footerTop) return;

                    const width = Math.max(1.5, line.widthPx || 2);
                    const color = line.color || '#444444';

                    ctx.strokeStyle = color;
                    ctx.lineWidth = width;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(line.x1, line.y1);
                    ctx.lineTo(line.x2, line.y2);
                    ctx.stroke();

                    // Draw arrowheads based on extracted arrow info
                    const angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
                    const arrowSize = Math.max(8, width * 3);

                    if (line.tailArrow) {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.moveTo(line.x2, line.y2);
                        ctx.lineTo(line.x2 - arrowSize * Math.cos(angle - Math.PI / 6),
                            line.y2 - arrowSize * Math.sin(angle - Math.PI / 6));
                        ctx.lineTo(line.x2 - arrowSize * Math.cos(angle + Math.PI / 6),
                            line.y2 - arrowSize * Math.sin(angle + Math.PI / 6));
                        ctx.closePath();
                        ctx.fill();
                    }
                    if (line.headArrow) {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.moveTo(line.x1, line.y1);
                        ctx.lineTo(line.x1 + arrowSize * Math.cos(angle - Math.PI / 6),
                            line.y1 + arrowSize * Math.sin(angle - Math.PI / 6));
                        ctx.lineTo(line.x1 + arrowSize * Math.cos(angle + Math.PI / 6),
                            line.y1 + arrowSize * Math.sin(angle + Math.PI / 6));
                        ctx.closePath();
                        ctx.fill();
                    }

                    union = unionBBox(union, {
                        left: Math.min(line.x1, line.x2) - 10,
                        top: Math.min(line.y1, line.y2) - 10,
                        right: Math.max(line.x1, line.x2) + 10,
                        bottom: Math.max(line.y1, line.y2) + 10
                    });
                });
            }

            // Draw clean label boxes on top (white background with text)
            labels.forEach(label => {
                const [x1, y1, x2, y2] = label.bbox;
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#555555';
                ctx.lineWidth = 1;
                ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                ctx.fillStyle = '#000000';
                const fontSize = Math.max(10, Math.min(14, Math.round((y2 - y1) * 0.65)));
                ctx.font = `500 ${fontSize}px Arial, sans-serif`;
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                ctx.fillText(label.text, (x1 + x2) / 2, (y1 + y2) / 2);
                union = unionBBox(union, { left: x1, top: y1, right: x2, bottom: y2 });
            });

            // Ensure we don't include header/footer in the crop
            union.top = Math.max(union.top, headerHeight);
            union.bottom = Math.min(union.bottom, footerTop);

            // Add small padding around content
            const pad = Math.round(Math.min(slideWidth, slideHeight) * 0.015);
            const crop = clampBBox({
                left: union.left - pad,
                top: union.top - pad,
                right: union.right + pad,
                bottom: union.bottom + pad
            }, slideWidth, slideHeight);

            const cropWidth = Math.max(1, crop.right - crop.left);
            const cropHeight = Math.max(1, crop.bottom - crop.top);

            const outCanvas = document.createElement('canvas');
            outCanvas.width = cropWidth;
            outCanvas.height = cropHeight;
            const outCtx = outCanvas.getContext('2d');
            outCtx.drawImage(canvas, crop.left, crop.top, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

            // Update label coordinates relative to cropped image
            labels.forEach(label => {
                label.bbox = [
                    label.bbox[0] - crop.left,
                    label.bbox[1] - crop.top,
                    label.bbox[2] - crop.left,
                    label.bbox[3] - crop.top
                ];
                label.center = [
                    label.center[0] - crop.left,
                    label.center[1] - crop.top
                ];
            });

            const blobOut = await new Promise(resolve => outCanvas.toBlob(resolve, 'image/png'));

            return {
                blob: blobOut,
                width: cropWidth,
                height: cropHeight,
                cropBBox: [crop.left, crop.top, crop.right, crop.bottom]
            };
        }

        function fillDownRows(rows) {
            if (!rows.length) return rows;
            const maxCols = Math.max(...rows.map(r => r.length));
            const last = new Array(maxCols).fill('');
            rows.forEach(row => {
                while (row.length < maxCols) row.push('');
                row.forEach((val, idx) => {
                    const text = (val || '').trim();
                    if (text) {
                        last[idx] = val;
                    } else if (last[idx]) {
                        row[idx] = last[idx];
                    }
                });
            });
            return rows;
        }

        function flattenTables(deckMeta, slideNumber, slideUid, titleGuess, tables, imageFile, tablesSha1, tableCount) {
            const records = [];
            tables.forEach((table, tableIndex) => {
                const cleaned = table.filter(row => row.some(cell => (cell || '').trim()));
                if (!cleaned.length) return;
                const header = cleaned[0];
                const body = cleaned.slice(1);

                const nonempty = header.filter(c => c.trim());
                let looksHeader = false;
                if (nonempty.length >= 2) {
                    let numericish = 0;
                    nonempty.forEach(c => {
                        if (/^[\d\W]+$/.test(c.trim())) numericish += 1;
                    });
                    looksHeader = numericish < Math.max(1, Math.floor(nonempty.length / 2));
                }

                if (looksHeader && body.length) {
                    const filled = fillDownRows(body);
                    const keys = header.map((k, i) => (k.trim() || `col_${i}`));
                    filled.forEach((row, rowIndex) => {
                        const rec = buildBaseRecord(deckMeta, slideNumber, slideUid, titleGuess, imageFile, tablesSha1, tableCount, tableIndex, rowIndex);
                        keys.forEach((key, idx) => {
                            rec[key] = (row[idx] || '').trim();
                        });
                        rec.raw = { cells: row };
                        rec.part_number = rec.Dash || rec['Part Number'] || rec['PART NUMBER'] || null;
                        records.push(rec);
                    });
                } else {
                    const filled = fillDownRows(cleaned);
                    filled.forEach((row, rowIndex) => {
                        const rec = buildBaseRecord(deckMeta, slideNumber, slideUid, titleGuess, imageFile, tablesSha1, tableCount, tableIndex, rowIndex);
                        row.forEach((val, idx) => {
                            rec[`col_${idx}`] = (val || '').trim();
                        });
                        rec.raw = { cells: row };
                        rec.part_number = null;
                        records.push(rec);
                    });
                }
            });
            return records;
        }

        function buildBaseRecord(deckMeta, slideNumber, slideUid, titleGuess, imageFile, tablesSha1, tableCount, tableIndex, rowIndex) {
            const slideIndex = slideNumber;
            return {
                table_row_id: `${slideUid}::t${tableIndex}::r${rowIndex}`,
                deck_id: deckMeta.deck_id,
                slide_uid: slideUid,
                slide_number: slideNumber,
                slide_index: slideIndex,
                slide_id: slideUid,
                title: titleGuess,
                zone: null,
                sequence: null,
                image_file: imageFile,
                source_pptx: deckMeta.file_name,
                source_slide_index: slideNumber,
                tables_sha1: tablesSha1,
                table_count: tableCount,
                table_index: tableIndex
            };
        }

        async function persistSlideResult(result) {
            if (result.slide.status === 'error') {
                await dbPut('slides', result.slide);
                await dbPut('labels', result.labels);
                return;
            }

            if (result.slide.slide_uid) {
                await deleteTableRowsForSlide(result.slide.slide_uid);
            }

            await dbPut('slides', result.slide);
            await dbPut('labels', result.labels);
            await dbPut('images', result.image);
            for (const row of result.tableRows) {
                await dbPut('table_rows', row);
            }
        }

        async function approveCurrentSlide() {
            const slide = state.slides[state.currentSlideIdx];
            if (!slide) return;
            slide.status = 'approved';
            slide.status_reason = null;
            await dbPut('slides', slide);
            renderSlideStatus(slide);
            updateStatusCounts();
            renderSlideList();
        }

        async function rejectCurrentSlide() {
            const slide = state.slides[state.currentSlideIdx];
            if (!slide) return;
            slide.status = 'rejected';
            slide.status_reason = null;
            await dbPut('slides', slide);
            renderSlideStatus(slide);
            updateStatusCounts();
            renderSlideList();
        }

        async function rerunCurrentSlide() {
            const slide = state.slides[state.currentSlideIdx];
            if (!slide) return;
            const deckMeta = state.decks.get(slide.deck_id);
            if (!deckMeta) {
                showToast('Deck data unavailable for re-run', 'error');
                return;
            }

            // Verify buffer is valid - check for ArrayBuffer or similar typed array
            const buffer = deckMeta.pptx_buffer;
            const hasValidBuffer = buffer && (
                (buffer instanceof ArrayBuffer && buffer.byteLength > 0) ||
                (buffer.buffer instanceof ArrayBuffer && buffer.byteLength > 0)
            );

            if (!hasValidBuffer) {
                showToast('Original file data not available. Please re-import the PDF/PPTX file.', 'error');
                return;
            }

            updateSettingsFromUI();
            setProcessing(true, 'Re-running Slide');

            let result;

            if (deckMeta.isPdf) {
                // PDF re-run - try cached PDF first, then reload from buffer
                try {
                    let pdf = state.pdfCache.get(deckMeta.deck_id);

                    if (!pdf) {
                        // Reload PDF from buffer
                        const bufferToUse = buffer instanceof ArrayBuffer ? buffer.slice(0) : new Uint8Array(buffer).buffer;
                        if (!bufferToUse || bufferToUse.byteLength === 0) {
                            throw new Error('File data is empty');
                        }
                        pdf = await pdfjsLib.getDocument({ data: bufferToUse }).promise;
                        state.pdfCache.set(deckMeta.deck_id, pdf);
                    }

                    result = await processPdfPage(pdf, deckMeta, slide.slide_number);
                } catch (err) {
                    console.error('PDF re-run error:', err);
                    showToast('PDF re-run failed: ' + err.message, 'error');
                    setProcessing(false);
                    return;
                }
            } else {
                // PPTX re-run
                const zip = await loadDeckZip(deckMeta);
                const slidePath = `ppt/slides/slide${slide.slide_number}.xml`;
                const presentationXml = await zip.file('ppt/presentation.xml')?.async('string');
                const slideSize = presentationXml ? parseSlideSize(presentationXml) : DEFAULT_SLIDE_SIZE;
                result = await processSlide(zip, deckMeta, slidePath, slide.slide_number, slideSize, slide);
            }

            if (result) {
                const idx = state.currentSlideIdx;
                state.slides[idx] = result.slide;
                state.slideByUid.set(result.slide.slide_uid, result.slide);
                state.labelsBySlide.set(result.slide.slide_uid, result.labels);
                state.tableRows = state.tableRows.filter(r => r.slide_uid !== result.slide.slide_uid);
                state.tableRows.push(...result.tableRows);
                if (result.image?.image_id) {
                    updateImageCache(result.image.image_id, result.image.blob);
                }
                await persistSlideResult(result);
                renderSlideList();
                await renderPreview(result.slide);
                renderSlideStatus(result.slide);
                renderLabels(result.slide.slide_uid);
                renderTables(result.slide.slide_uid);
                updateStatusCounts();
            }
            setProcessing(false);
        }

        async function handleMasterJsonImport(e) {
            const file = e.target.files?.[0];
            if (!file) return;

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (!data.all_rows || !Array.isArray(data.all_rows)) {
                    showToast('Invalid JSON: missing all_rows array', 'error');
                    return;
                }

                state.masterPartsData = data;
                showToast(`Loaded ${data.all_rows.length} parts from ${file.name}`, 'success');

                // Refresh current slide's table view
                const slide = state.slides[state.currentSlideIdx];
                if (slide) {
                    renderTables(slide.slide_uid);
                }
            } catch (err) {
                console.error('JSON import error:', err);
                showToast('Failed to parse JSON: ' + err.message, 'error');
            }

            e.target.value = ''; // Reset input
        }


        async function buildExportBundle() {
            const approvedOnly = ui.exportOptions.approvedOnly.checked;
            const includeImages = ui.exportOptions.images.checked;
            const includeLabels = ui.exportOptions.labels.checked;
            const includeTables = ui.exportOptions.tables.checked;
            const includeSqlite = ui.exportOptions.sqlite.checked;

            const slides = state.slides;
            const exportSlides = approvedOnly ? slides.filter(s => s.status === 'approved') : slides;

            const manifestSlides = slides.map(slide => {
                const allow = approvedOnly ? slide.status === 'approved' : true;
                return {
                    deck_id: slide.deck_id,
                    slide_number: slide.slide_number,
                    slide_uid: slide.slide_uid,
                    title_guess: slide.title_guess,
                    status: slide.status,
                    status_reason: slide.status_reason || null,
                    composite: allow ? slide.composite : null,
                    labels: allow ? slide.labels : { count: 0, labels_file: 'slides/labels.json' },
                    tables: slide.tables
                };
            });

            const labelsPayload = includeLabels ? exportSlides.map(slide => state.labelsBySlide.get(slide.slide_uid)).filter(Boolean) : [];
            const tableRows = includeTables ? state.tableRows.filter(row => {
                const slide = state.slideByUid.get(row.slide_uid);
                return slide && (!approvedOnly || slide.status === 'approved');
            }) : [];

            const zip = new JSZip();
            const timestamp = new Date().toISOString();

            const project = {
                project_version: '1.0',
                generated_at: timestamp,
                app: { name: 'slide_stripper_web', build: 'dev' },
                sources: Array.from(state.decks.values()).map(deck => ({
                    deck_id: deck.deck_id,
                    file_name: deck.file_name,
                    slides: deck.slide_count
                }))
            };

            zip.file('project.json', JSON.stringify(project, null, 2));
            zip.file('slides/manifest_slides.json', JSON.stringify({ generated_at: timestamp, slides: manifestSlides }, null, 2));

            if (includeLabels) {
                zip.file('slides/labels.json', JSON.stringify(labelsPayload, null, 2));
            }

            if (includeTables) {
                zip.file('data/master_parts.json', JSON.stringify(tableRows, null, 2));
                const csv = buildCsv(tableRows);
                zip.file('data/master_parts.csv', csv);
            }

            if (includeImages) {
                for (const slide of exportSlides) {
                    if (!slide.composite?.image_id) continue;
                    const blob = await getImageBlob(slide.composite.image_id);
                    if (!blob) continue;
                    // Use slide number-based filename for export
                    const slideNum = String(slide.slide_number).padStart(4, '0');
                    const exportFilename = `slides/images/slide_${slideNum}.png`;
                    zip.file(exportFilename, blob);
                }
            }

            const partIndex = buildPartIndex(tableRows);
            zip.file('index/part_index.json', JSON.stringify(partIndex, null, 2));

            const mapperLink = buildMapperLink(exportSlides);
            if (mapperLink) {
                zip.file('mapper/mapper_link.json', JSON.stringify(mapperLink, null, 2));
            }

            if (includeSqlite) {
                const sqliteBlob = await buildSqliteFile(tableRows, exportSlides, labelsPayload);
                zip.file('data/master_parts.sqlite', sqliteBlob);
            }

            return zip.generateAsync({ type: 'blob' });
        }

        function buildPartIndex(rows) {
            const index = {};
            rows.forEach(row => {
                const part = row.part_number || row.Dash || row['Part Number'] || row['PART NUMBER'];
                if (!part) return;
                const key = part.trim();
                if (!index[key]) index[key] = [];
                if (!index[key].includes(row.slide_uid)) index[key].push(row.slide_uid);
            });
            return index;
        }

        function buildMapperLink(exportSlides) {
            const selected = state.slides[state.currentSlideIdx];
            const active = selected && exportSlides.includes(selected) ? selected : exportSlides[0];
            if (!active || !active.composite) return null;
            return {
                active_image: {
                    slide_uid: active.slide_uid,
                    image_id: active.composite.image_id,
                    image_file: active.composite.image_file,
                    labels_file: 'slides/labels.json',
                    tables_file: 'data/master_parts.json'
                }
            };
        }

        function buildCsv(rows) {
            if (!rows.length) return '';
            const columns = new Set();
            rows.forEach(row => Object.keys(row).forEach(key => columns.add(key)));
            const header = Array.from(columns);
            const lines = [header.join(',')];
            rows.forEach(row => {
                const values = header.map(key => {
                    let value = row[key];
                    if (value && typeof value === 'object') value = JSON.stringify(value);
                    const text = String(value ?? '');
                    const escaped = text.replace(/"/g, '""');
                    return `"${escaped}"`;
                });
                lines.push(values.join(','));
            });
            return lines.join('\n');
        }

        async function buildSqliteFile(rows, exportSlides, labelsPayload) {
            if (!window.initSqlJs) {
                throw new Error('sql.js failed to load');
            }
            if (!sqlInitPromise) {
                sqlInitPromise = initSqlJs({
                    locateFile: file => `https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/${file}`
                });
            }
            const SQL = await sqlInitPromise;
            const db = new SQL.Database();

            db.run('CREATE TABLE slides (slide_uid TEXT, deck_id TEXT, slide_number INTEGER, status TEXT, image_file TEXT, title_guess TEXT)');
            const slideStmt = db.prepare('INSERT INTO slides VALUES (?, ?, ?, ?, ?, ?)');
            exportSlides.forEach(slide => {
                slideStmt.run([slide.slide_uid, slide.deck_id, slide.slide_number, slide.status, slide.composite?.image_file || null, slide.title_guess || null]);
            });
            slideStmt.free();

            if (rows.length) {
                const columns = Array.from(new Set(rows.flatMap(r => Object.keys(r))));
                const columnSql = columns.map(c => `"${c}" TEXT`).join(', ');
                db.run(`CREATE TABLE master_parts (${columnSql})`);
                const placeholders = columns.map(() => '?').join(',');
                const stmt = db.prepare(`INSERT INTO master_parts (${columns.map(c => `"${c}"`).join(',')}) VALUES (${placeholders})`);
                rows.forEach(row => {
                    const values = columns.map(c => {
                        const value = row[c];
                        return typeof value === 'object' ? JSON.stringify(value) : (value ?? null);
                    });
                    stmt.run(values);
                });
                stmt.free();
            }

            if (labelsPayload.length) {
                db.run('CREATE TABLE labels (slide_uid TEXT, image_id TEXT, text TEXT, x1 INTEGER, y1 INTEGER, x2 INTEGER, y2 INTEGER, cx INTEGER, cy INTEGER, confidence REAL)');
                const stmt = db.prepare('INSERT INTO labels VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)');
                labelsPayload.forEach(payload => {
                    payload.labels.forEach(label => {
                        stmt.run([
                            payload.slide_uid,
                            payload.image_id,
                            label.text,
                            label.bbox[0],
                            label.bbox[1],
                            label.bbox[2],
                            label.bbox[3],
                            label.center[0],
                            label.center[1],
                            label.confidence
                        ]);
                    });
                });
                stmt.free();
            }

            const data = db.export();
            return new Blob([data], { type: 'application/octet-stream' });
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }

        async function handleDownloadZip() {
            try {
                const blob = await buildExportBundle();
                const stamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                downloadBlob(blob, `slide_stripper_export_${stamp}.zip`);
            } catch (err) {
                showToast(err.message || 'Export failed', 'error');
            }
        }

        async function handleDownloadSqlite() {
            try {
                const approvedOnly = ui.exportOptions.approvedOnly.checked;
                const exportSlides = approvedOnly ? state.slides.filter(s => s.status === 'approved') : state.slides;
                const tableRows = state.tableRows.filter(row => {
                    const slide = state.slideByUid.get(row.slide_uid);
                    return slide && (!approvedOnly || slide.status === 'approved');
                });
                const labelsPayload = exportSlides.map(slide => state.labelsBySlide.get(slide.slide_uid)).filter(Boolean);
                const sqliteBlob = await buildSqliteFile(tableRows, exportSlides, labelsPayload);
                downloadBlob(sqliteBlob, 'master_parts.sqlite');
            } catch (err) {
                showToast(err.message || 'SQLite export failed', 'error');
            }
        }

        async function handleDownloadImagesZip() {
            const approvedOnly = ui.exportOptions.approvedOnly.checked;
            const exportSlides = approvedOnly
                ? state.slides.filter(s => s.status === 'approved')
                : state.slides;

            if (exportSlides.length === 0) {
                showToast('No slides to export', 'error');
                return;
            }

            setProcessing(true, 'Building Images ZIP');

            try {
                const zip = new JSZip();
                const imagesFolder = zip.folder('images');

                for (let i = 0; i < exportSlides.length; i++) {
                    const slide = exportSlides[i];
                    updateProgress(i, exportSlides.length, `Adding slide ${slide.slide_number}...`);

                    if (slide.composite?.image_id) {
                        const blob = await getImageBlob(slide.composite.image_id);
                        if (blob) {
                            // Name file by slide number, zero-padded
                            const filename = `slide_${String(slide.slide_number).padStart(4, '0')}.png`;
                            imagesFolder.file(filename, blob);
                        }
                    }
                }

                updateProgress(exportSlides.length, exportSlides.length, 'Generating ZIP...');
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                const stamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                downloadBlob(zipBlob, `slide_images_${stamp}.zip`);
                showToast(`Exported ${exportSlides.length} images`, 'success');
            } catch (err) {
                console.error('Images ZIP error:', err);
                showToast('Failed to create images ZIP: ' + err.message, 'error');
            }

            setProcessing(false);
        }

        async function handleSaveImagesToFolder() {
            const approvedOnly = ui.exportOptions.approvedOnly.checked;
            const exportSlides = approvedOnly
                ? state.slides.filter(s => s.status === 'approved')
                : state.slides;

            if (exportSlides.length === 0) {
                showToast('No slides to export', 'error');
                return;
            }

            // Check for File System Access API support
            if (!('showDirectoryPicker' in window)) {
                showToast('Your browser does not support folder selection. Use Chrome or Edge.', 'error');
                return;
            }

            let dirHandle;
            try {
                dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
            } catch (err) {
                if (err.name !== 'AbortError') {
                    showToast('Failed to select folder: ' + err.message, 'error');
                }
                return;
            }

            setProcessing(true, 'Saving Images to Folder');

            try {
                let saved = 0;
                for (let i = 0; i < exportSlides.length; i++) {
                    const slide = exportSlides[i];
                    updateProgress(i, exportSlides.length, `Saving slide ${slide.slide_number}...`);

                    if (slide.composite?.image_id) {
                        const blob = await getImageBlob(slide.composite.image_id);
                        if (blob) {
                            const filename = `slide_${String(slide.slide_number).padStart(4, '0')}.png`;
                            const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(blob);
                            await writable.close();
                            saved++;
                        }
                    }
                }

                updateProgress(exportSlides.length, exportSlides.length, 'Done!');
                showToast(`Saved ${saved} images to folder`, 'success');
            } catch (err) {
                console.error('Save to folder error:', err);
                showToast('Failed to save images: ' + err.message, 'error');
            }

            setProcessing(false);
        }

        async function rescanAllSlides() {
            if (state.slides.length === 0) {
                showToast('No slides to rescan', 'error');
                return;
            }

            updateSettingsFromUI();
            setProcessing(true, 'Rescanning All Slides');

            let processed = 0;
            const total = state.slides.length;

            for (const slide of state.slides) {
                updateProgress(processed, total, `Rescanning slide ${slide.slide_number}...`);

                const deckMeta = state.decks.get(slide.deck_id);
                if (!deckMeta) {
                    processed++;
                    continue;
                }

                try {
                    let result;

                    if (deckMeta.isPdf) {
                        // Get or reload PDF
                        let pdf = state.pdfCache.get(deckMeta.deck_id);
                        if (!pdf && deckMeta.pptx_buffer) {
                            const buffer = deckMeta.pptx_buffer instanceof ArrayBuffer
                                ? deckMeta.pptx_buffer.slice(0)
                                : new Uint8Array(deckMeta.pptx_buffer).buffer;
                            pdf = await pdfjsLib.getDocument({ data: buffer }).promise;
                            state.pdfCache.set(deckMeta.deck_id, pdf);
                        }
                        if (pdf) {
                            result = await processPdfPage(pdf, deckMeta, slide.slide_number);
                        }
                    } else {
                        // PPTX
                        const zip = await loadDeckZip(deckMeta);
                        const slidePath = `ppt/slides/slide${slide.slide_number}.xml`;
                        const presentationXml = await zip.file('ppt/presentation.xml')?.async('string');
                        const slideSize = presentationXml ? parseSlideSize(presentationXml) : DEFAULT_SLIDE_SIZE;
                        result = await processSlide(zip, deckMeta, slidePath, slide.slide_number, slideSize, slide);
                    }

                    if (result) {
                        const idx = state.slides.indexOf(slide);
                        state.slides[idx] = result.slide;
                        state.slideByUid.set(result.slide.slide_uid, result.slide);
                        state.labelsBySlide.set(result.slide.slide_uid, result.labels);
                        state.tableRows = state.tableRows.filter(r => r.slide_uid !== result.slide.slide_uid);
                        state.tableRows.push(...result.tableRows);
                        if (result.image?.image_id) {
                            updateImageCache(result.image.image_id, result.image.blob);
                        }
                        await persistSlideResult(result);
                    }
                } catch (err) {
                    console.error(`Error rescanning slide ${slide.slide_number}:`, err);
                }

                processed++;
            }

            setProcessing(false);
            renderSlideList();
            updateStatusCounts();

            // Refresh current slide preview
            const currentSlide = state.slides[state.currentSlideIdx];
            if (currentSlide) {
                await renderPreview(currentSlide);
                renderLabels(currentSlide.slide_uid);
                renderTables(currentSlide.slide_uid);
            }

            showToast(`Rescanned ${total} slides with new settings`, 'success');
        }

        async function openMapperLink() {
            const slide = state.slides[state.currentSlideIdx];
            if (!slide) return;
            const mapperLink = {
                active_image: {
                    slide_uid: slide.slide_uid,
                    image_id: slide.composite?.image_id || null,
                    image_file: slide.composite?.image_file || null,
                    labels_file: 'slides/labels.json',
                    tables_file: 'data/master_parts.json'
                }
            };
            try {
                localStorage.setItem('slideStripper:mapperLink', JSON.stringify(mapperLink));
            } catch (err) { }
            try { window.open('blueprint_mapper.html', '_blank'); } catch (err) { }
            showToast('Opened mapper. Export ZIP for mapper_link.json.', 'info');
        }

        ui.tabs.forEach(tab => {
            tab.addEventListener('click', () => setActiveScreen(tab.dataset.screen));
        });

        ui.browseBtn.addEventListener('click', () => ui.pptxInput.click());
        ui.pptxInput.addEventListener('change', (e) => addFiles(e.target.files));

        ui.dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            ui.dropZone.classList.add('dragover');
        });
        ui.dropZone.addEventListener('dragleave', () => ui.dropZone.classList.remove('dragover'));
        ui.dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            ui.dropZone.classList.remove('dragover');
            addFiles(e.dataTransfer.files);
        });

        ui.startProcessing.addEventListener('click', startProcessing);

        ui.settings.regexPreset.addEventListener('change', () => {
            if (ui.settings.regexPreset.value !== 'custom') {
                ui.settings.regex.value = LABEL_PRESETS[ui.settings.regexPreset.value];
            }
        });

        ui.settings.apply.addEventListener('click', () => {
            updateSettingsFromUI();
            showToast('Settings stored for re-run', 'success');
        });

        ui.approveBtn.addEventListener('click', approveCurrentSlide);
        ui.rejectBtn.addEventListener('click', rejectCurrentSlide);
        ui.rerunBtn.addEventListener('click', rerunCurrentSlide);
        ui.openMapperBtn.addEventListener('click', openMapperLink);

        // Master JSON import
        ui.importMasterJson.addEventListener('click', () => ui.masterJsonInput.click());
        ui.masterJsonInput.addEventListener('change', handleMasterJsonImport);

        // Rescan all slides
        ui.rescanAllSlides.addEventListener('click', rescanAllSlides);

        ui.downloadZip.addEventListener('click', handleDownloadZip);
        ui.downloadImagesZip.addEventListener('click', handleDownloadImagesZip);
        ui.saveImagesFolder.addEventListener('click', handleSaveImagesToFolder);
        ui.downloadSqlite.addEventListener('click', handleDownloadSqlite);

        Array.from(document.querySelectorAll('input[name="mode"]')).forEach(radio => {
            radio.addEventListener('change', (e) => {
                state.appendMode = e.target.value;
            });
        });

        ui.settings.regex.value = LABEL_PRESETS.general;
        ui.settings.regexPreset.value = 'general';

        window.addEventListener('keydown', (e) => {
            if (ui.screens.review.classList.contains('active')) {
                if (e.key === 'a' || e.key === 'A') {
                    approveCurrentSlide();
                } else if (e.key === 'r' || e.key === 'R') {
                    if (e.shiftKey) {
                        rerunCurrentSlide();
                    } else {
                        rejectCurrentSlide();
                    }
                } else if (e.key === 'ArrowRight') {
                    if (state.currentSlideIdx < state.slides.length - 1) selectSlide(state.currentSlideIdx + 1);
                } else if (e.key === 'ArrowLeft') {
                    if (state.currentSlideIdx > 0) selectSlide(state.currentSlideIdx - 1);
                }
            }
        });

        // Zoom functionality
        function updateZoom(zoom) {
            state.zoom = Math.max(25, Math.min(400, zoom));
            ui.zoomSlider.value = state.zoom;
            ui.zoomValue.textContent = `${state.zoom}%`;
            const scale = state.zoom / 100;
            ui.previewCanvas.style.transform = `scale(${scale})`;
            ui.previewCanvas.style.transformOrigin = 'top center';
        }

        function zoomToFit() {
            const viewport = ui.previewViewport;
            const canvas = ui.previewCanvas;
            if (!canvas.width || !canvas.height) return;
            const vw = viewport.clientWidth - 40;
            const vh = viewport.clientHeight - 40;
            const scaleW = vw / canvas.width;
            const scaleH = vh / canvas.height;
            const scale = Math.min(scaleW, scaleH, 1) * 100;
            updateZoom(Math.round(scale / 25) * 25);
        }

        ui.zoomSlider.addEventListener('input', () => updateZoom(parseInt(ui.zoomSlider.value)));
        ui.zoomIn.addEventListener('click', () => updateZoom(state.zoom + 25));
        ui.zoomOut.addEventListener('click', () => updateZoom(state.zoom - 25));
        ui.zoomFit.addEventListener('click', zoomToFit);
        ui.zoomReset.addEventListener('click', () => updateZoom(100));

        // Mouse wheel zoom in preview viewport
        ui.previewViewport.addEventListener('wheel', (e) => {
            if (e.ctrlKey) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -25 : 25;
                updateZoom(state.zoom + delta);
            }
        }, { passive: false });

        loadExistingSession();
    </script>
</body>

</html>